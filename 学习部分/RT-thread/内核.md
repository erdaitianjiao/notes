### 内核简介

- 内核介绍

  > - 内核是一个操作系统的核心，它负责管理系统的**线程、线程间通信、系统时钟、中断及内存**，内核包括内核库，实时实现内核实现

  > [!NOTE]  
  > 内核库是为了保证内核能够独立运行的一套小型的类似 C 库的函数实现子集。
  > 这部分根据编译器的不同自带 C 库的情况也会有些不同，当使用 GNU GCC 编译器时，会携带更多的标准 C 库实现

  >内核实现包括：对象管理、线程管理、以及调度器、线程间通信管理、时钟管理和内存管理
  >
  >内核最小的资源占用情况是 3KB ROM，1.2KB RAM


- 线程调度

  > - 线程是RT-Thread操作系统中最小的调度单位
  >
  > 并且有基于**抢占式多线程**的调度算法，在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的，包括线程调度器自身
  >
  > 支持 256 个线程优先级，0 优先级代表最高优先级，最低优先级留给空闲线程使用
  >
  > 当创建相同优先级的线程间时采用时间片的轮转调度算法进行调度，使每个线程运行相应时间
  
- 时钟管理

  >- 时钟节拍是 RT-Thread 操作系统中最小的时钟单位
  >
  >RT-Thread 的定时器提供**两类定时器机制**：
  >
  >第一类是单次触发定时器，这类定时器在启动后只会触发一次定时器事件，然后定时器自动停止
  >
  >第二类是周期触发定时器，这类定时器会周期性的触发定时器事件，直到用户手动的停止定时器否则将一直执行
  >
  >另外，根据超时函数执行时所处的上下文环境，RT-Thread 的定时器可以设置为 HARD_TIMER 模式或者 SOFT_TIMER 模式

- 线程间同步

  > - RT-Thread 采用**信号量、互斥量与事件集**实现线程间同步
  >
  > 线程通过对信号量、互斥量的获取与释放进行同步
  >
  > 互斥量也解决了优先级反转的问题
  >
  > 线程同步机制支持线程按优先级等待方式获取信号量或互斥量
  >
  > 事件集支持多事件的 “或触发” 和“与触发”，适合于线程等待多个事件的情况

- 线程间通信

  > - RT-Thread 支持**邮箱和消息队列**等通信机制
  >
  > 邮箱中一封邮箱的固定长度为4字节
  >
  > 消息队列的长度可以不固定，而且可以缓存
  >
  > 邮箱效率比消息队列更高
  >
  > 邮箱和消息队列的发送动作可安全用于中断服务例程中 
  >
  > 通信机制支持线程按优先级等待方式获取

- 内存管理

  > - RT-Thread 支持静态内存池管理及动态内存堆管理
  >
  > 1. 当静态内存池具有可用内存时，系统对内存块分配的时间将是恒定的；
  >
  > 2. 当静态内存池为空时，系统将申请内存块的线程挂起或阻塞掉 (即线程等待一段时间后仍未获得内存块就放弃申请并返回，或者立刻返回等待的时间取决于申请内存块时设置的等待时间参数)
  > 3. 当其他线程释放内存块到内存池时，如果有挂起的待分配内存块的线程存在的话，则系统会将这个线程唤醒
  >
  > - 动态内存堆管理模块在系统资源不同的情况下，分别提供了面向小内存系统的内存管理算法及面向大内存系统的 SLAB 内存管理算法
  >
  > - 还有一种动态内存堆管理叫做 memheap，适用于系统含有多个地址且不连续的内存堆。使用 memheap 可以将多个内存堆 “粘贴” 在一起，让用户操作起来像是在操作一个内存堆

- I/O 设备管理

  > - RT-Thread 将 **PIN、I2C、SPI、USB、UART** 等作为外设设备，统一通过设备注册完成
  >
  > 实现了按名称访问的设备管理子系统，可按照统一的 API 界面访问硬件设备。
  >
  > 在设备驱动接口上，根据嵌入式系统的特点，对不同的设备可以挂接相应的事件。
  >
  > 当设备事件触发时，由驱动程序通知给上层的应用程序

