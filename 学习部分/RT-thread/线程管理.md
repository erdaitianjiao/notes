### 线程管理

- 简介

  > **引入**：在多线程操作系统中，需要一个复杂的应用分解成多个小的，可调度的，序列化的程序单元，当合理地划分任务并正确地执行时，这种设计能够让系统满足实时系统的性能及时间的要求
  >
  > **eg.** 例如让嵌入式系统执行这样的任务，系统通过传感器采集数据，并通过显示屏将数据显示出来，在多线程实时系统中
  >
  > 可以将这个任务分解成两个子任务，一个子任务不间断地读取传感器数据，并将数据写到共享内存中，另外一个子任务周期性的从共享内存中读取数据，并将传感器数据输出到显示屏上。

-  线程

  > - 在 RT-Thread 中，与上述子任务对应的程序实体就是线程
  >
  > 1. 线程是实现任务的载体，线程是RT-Thread 中最基本的调度单位，描述了一个任务执行的运行环境，也描述了个任务所处的优先等级，控任务的执行顺序和逻辑
  >
  > 2.  当线程运行时，它会认为自己是以独占 CPU 的方式在运行。
  >
  > 3.  **上下文**是线程执行时的运行环境称，具体来说就是各个变量和数据，包括所有的寄存器变量、堆栈、内存信息等。



#### 线程管理的功能特点

- 简介

  > - 线程管理是对线程的管理和调度。
  >
  >   系统中存在两种线程，分别是**系统进程和用户进程**
  >
  >   - 系统线程是由 **RT-Thread 内核**创建的线程
  >   - 用户线程是由**应用程序**创建的线程
  >
  >   这两类线程都会从内核对象容器中分配线程对象，当线程被删除时，也会被从对象容器中删除
  >
  >   - 线程的重要属性
  >
  >     > 线程控制块、线程栈、入口函数
  >
  >   1. 抢占式线程调度器主要的工作就是从就绪线程列表中找到最高优先级线程，并使得最高优先级的线程能够被运行
  >   
  >   2. 当一个运行着的线程使一个比它优先级高的线程满足运行条件，当前线程的 CPU 使用权就被剥夺了，或者说被让出了，高优先级的线程立刻得到了 CPU 的使用权。
  >   
  >   3. 如果是中断服务程序使一个高优先级的线程满足运行条件，中断完成时，被中断的线程挂起，优先级高的线程开始运行。
  >   
  >   4. 当调度器调度线程切换时，先将当前线程上下文保存起来，当再切回到这个线程时，线程调度器将该线程的上下文信息恢复。
  >   
  
  

####  线程的工作机制

- 线程控制模块
  
  >
  > 线程控制块是一种数据结构用于管理线程，它存储线程的优先级.，线程名称，线程状态等信息
  > 
  > 下面是struct rt_thread详细定义
  > ~~~c
  > /* 线程控制块 */
  > struct rt_thread
  > {
  >  /* rt 对象 */
  >  char        name[RT_NAME_MAX];     /* 线程名称 */
  >  rt_uint8_t  type;                   /* 对象类型 */
  >  rt_uint8_t  flags;                  /* 标志位 */
  > 
  >  rt_list_t   list;                   /* 对象列表 */
  >  rt_list_t   tlist;                  /* 线程列表 */
  > 
  >  /* 栈指针与入口指针 */
  >  void       *sp;                      /* 栈指针 */
  >  void       *entry;                   /* 入口函数指针 */
  >  void       *parameter;              /* 参数 */
  >  void       *stack_addr;             /* 栈地址指针 */
  >  rt_uint32_t stack_size;            /* 栈大小 */
  > 
  >  /* 错误代码 */
  >  rt_err_t    error;                  /* 线程错误代码 */
  >  rt_uint8_t  stat;                   /* 线程状态 */
  > 
  >  /* 优先级 */
  >  rt_uint8_t  current_priority;    /* 当前优先级 */
  >  rt_uint8_t  init_priority;        /* 初始优先级 */
  >  rt_uint32_t number_mask;
  > 
  >  ......
  > 
  >  rt_ubase_t  init_tick;               /* 线程初始化计数值 */
  >  rt_ubase_t  remaining_tick;         /* 线程剩余计数值 */
  > 
  >  struct rt_timer thread_timer;      /* 内置线程定时器 */
  > 
  >  void (*cleanup)(struct rt_thread *tid);  /* 线程退出清除函数 */
  >  rt_uint32_t user_data;                      /* 用户数据 */
  > };
  > 
  > ~~~
  >
  > - 其中init_poriority是创建线程时指定的线程优先级，在线程运行过程中不会自动改变
  > - cleanup会在线程退出时，被空闲线程回调一次执行用户设置的清理现场的工作
  > - 最后的一个成员 user_data 可由用户挂接一些数据信息到线程控制块中，以提供一种类似线程私有数据的实现方式

- 线程的重要属性

  > - 线程栈
  >   1. RT-Thread线程具有独立的栈,当进行线程切换的时候，会将当前线程的上下文存在栈中，当线程要恢复运行时，再从栈中读取上下文信息，进行恢复
  >   2. 线程栈还用来存放函数中的局部变量：函数中的局部变量从线程栈空间中申请；函数中局部变量初始时从寄存器中分配（ARM 架构），当这个函数再调用另一个函数时，这些局部变量将放入栈中
  >   3. 线程栈的增长方向是芯片构架密切相关的，RT-Thread 3.1.0 以前的版本，均只支持栈由高地址向低地址增长的方式
  >   4. 对于资源相对较大的 MCU，可以适当设计较大的线程栈；也可以在初始时设置较大的栈，例如指定大小为 1K 或 2K 字节，然后在 FinSH 中用 list_thread 命令查看线程运行的过程中线程所使用的栈的大小，通过此命令，能够看到从线程启动运行时，到当前时刻点，线程使用的最大栈深度，而后加上适当的余量形成最终的线程栈大小，最后对栈空间大小加以修改

- 线程状态

  > - 线程运行过程中，同一个时间内只允许一个线程的处理器运行，线程从运行过程上来划分有多种运行状态，如初始状态、挂起状态、就绪状态等
  >
  >  RT-Thread 中线程的五种状态，如下表所示：
  >
  > | 状态     | 描述                                                         |
  > | -------- | ------------------------------------------------------------ |
  > | 初始状态 | 当线程刚创建还没开始运行时就处于初始状态；在初始状态下，线程不参与调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_INIT |
  > | 就绪状态 | 在就绪状态下，线程按优先级排队，等待被执行；一旦当前线程运行完毕让出处理器，操作系统会马上寻找最高优先级的就绪态线程运行。此状态在 RT-Thread 中的宏定义为 RT_THREAD_READY |
  > | 运行状态 | 线程当前正在运行。在单核系统中，只有 rt_thread_self() 函数返回的线程处于运行状态；在多核系统中，可能就不止这一个线程处于运行状态。此状态在 RT-Thread 中的宏定义为 RT_THREAD_RUNNING |
  > | 挂起状态 | 也称阻塞态。它可能因为资源不可用而挂起等待，或线程主动延时一段时间而挂起。在挂起状态下，线程不参与调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_SUSPEND |
  > | 关闭状态 | 当线程运行结束时将处于关闭状态。关闭状态的线程不参与线程的调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_CLOSE |
  
- 线程优先级

  > - 优先级是表示小城被调度的优先程度，每个线程都具有优先级，线程越重要，赋予的优先级就应越高，线程被调度的可能才会越大
  >
  > 1. RT-Thread 最大支持 256 个线程优先级 (0~255)，数值越小的优先级越高，0 为最高优先级。在一些资源比较紧张的系统中，可以根据实际情况选择只支持 8 个或 32 个优先级的系统配置；
  >
  > 2. 对于 ARM Cortex-M 系列，普遍采用 32 个优先级。最低优先级默认分配给空闲线程使用，用户一般不使用
  >
  > 3. 在系统中，当有比当前线程优先级更高的线程就绪时，当前线程将立刻被换出，高优先级线程抢占处理器运行

- 时间片

  > - 每个线程都有时间片这个参数，但时间片仅对优先级相同的就绪态线程有效，对优先级相同的就绪线程系统采用时间片轮转的调度方式进行调度，时间片是约束单次线程运行时长的，单位是一个系统节拍（OS Tick）
  
- 线程的入口函数

  > - 线程控制块中的entry是线程的入口函数，线程的入口函数由用户设计实现，一般有两种代码形式
  >
  >   - 无限循环
  >
  >     > 在实时操作系统中，线程通常是被动式的，实时系统总是等待外部事件发生，而后进行相应的服务
  >     >
  >     > ~~~c
  >     > void thread_entry(void* paramenter)
  >     > {
  >     >     while (1)
  >     >     {
  >     >     /* 等待事件的发生 */
  >     > 
  >     >     /* 对事件进行服务、进行处理 */
  >     >     }
  >     > }
  >     > ~~~
  >     >
  >     > 线程看似没有什么限制程序执行的因素，似乎所有的操作都可以执行。但是作为一个实时系统而言，一个优先级明确的实时系统，如果一个线程中的程序陷入了死循环操作，那么比它优先级低的线程都不能得到执行。
  >     >
  >     > 所以在实时操作系统中必须注意的一点就是：**线程中不能陷入死循环操作**，必须要有让出 CPU 使用权的动作，如循环中调用延时函数或者主动挂起。用户设计这种无限循环的线程的目的，就是为了让这个线程一直被系统循环调度运行，永不删除。
  >
  >   - 顺序执行或有限次数循环
  >
  >     > 比如简单的顺序语句，有限次数的for语句，此类线程不会永久循环，所以为"一次性线程"，被执行完毕后，线程将会被自动删除
  >     >
  >     > ~~~c
  >     > static void thread_entry(void* parameter)
  >     > {
  >     >     /* 处理事务 #1 */
  >     >     …
  >     >     /* 处理事务 #2 */
  >     >     …
  >     >     /* 处理事务 #3 */
  >     > }
  >     > ~~~

- 线程错误码

  > 一个线程就是一个执行场景，错误码是与执行环境密切相关的，所以每个线程配备了一个变量用于保存错误码，错误码类型如下
  > ~~~c
  > #define RT_EOK           0 /* 无错误     */
  > #define RT_ERROR         1 /* 普通错误     */
  > #define RT_ETIMEOUT      2 /* 超时错误     */
  > #define RT_EFULL         3 /* 资源已满     */
  > #define RT_EEMPTY        4 /* 无资源     */
  > #define RT_ENOMEM        5 /* 无内存     */
  > #define RT_ENOSYS        6 /* 系统不支持     */
  > #define RT_EBUSY         7 /* 系统忙     */
  > #define RT_EIO           8 /* IO 错误       */
  > #define RT_EINTR         9 /* 中断系统调用   */
  > #define RT_EINVAL       10 /* 非法参数      */
  > 
  > ~~~



##### 线程状态切换

- 简介

  > RT-Thread 提供一系列的操作系统调用接口，使得线程的状态在这五个状态之间来回切换，转换图如下
  >
  > ![04thread_sta](pic\04thread_sta.png)
  > 线程通过调用函数 rt_thread_create/init() 进入到初始状态（RT_THREAD_INIT）；
  >
  > 初始状态的线程通过调用函数 rt_thread_startup() 进入到就绪状态（RT_THREAD_READY）；
  >
  > 就绪状态的线程被调度器调度后进入运行状态（RT_THREAD_RUNNING）；
  >
  > 当处于运行状态的线程调用 rt_thread_delay()，rt_sem_take()，rt_mutex_take()，rt_mb_recv() 等函数或者获取不到资源时，将进入到挂起状态（RT_THREAD_SUSPEND）；
  >
  > 处于挂起状态的线程，如果等待超时依然未能获得资源或由于其他线程释放了资源，那么它将返回到就绪状态。挂起状态的线程，如果调用 rt_thread_delete/detach() 函数，将更改为关闭状态（RT_THREAD_CLOSE）；而运行状态的线程，如果运行结束，就会在线程的最后部分执行 rt_thread_exit() 函数，将状态更改为关闭状态。

- 系统线程

  > 系统线程是指由系统创建的线程，用户线程是由用户调用线程管理接口创建的线程，在 RT-Thread 内核中的系统线程有空闲线程和主线程。
  >
  > - 空闲线程
  >
  >   > 空闲线程（idle）是系统创建的最低优先级的线程，线程状态永远为就绪态。当系统各种无其他线程时，调度器将调度到空闲线程，空闲线程通常是一个死循环，并且不会被挂起。
  >   >
  >   > 当某个线程执行完毕的时候。系统会自动删除线程，自动执行rt_thread_exit() 函数，先将该线程从系统就绪队列中删除，再将线程改为关闭状态，然后挂入rt_thread_defunct 僵尸队列（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。
  >   >
  >   > 空闲线程也提供了接口来运行用户设置的钩子函数，在空闲线程运行时会调用该钩子函数，适合处理功耗管理、看门狗喂狗等工作。空闲线程必须有得到执行的机会，即其他线程不允许一直while(1)死卡，必须调用具有阻塞性质的函数；否则例如线程删除、回收等操作将无法得到正确执行。
  >
  > - 主线程
  >
  >   > 在系统启动时，系统会创建main线程，它的入口函数为main_thread_entry()，用户的应用入口函数main()，就是在这里真正开始的，系统调度器启动后，main 线程就开始运行，过程如下图![04main_thread](pic\04main_thread.png)



#### 线程的管理方式

- 简介

  > 下图描述了线程的相关操作，包含：创建 / 初始化线程、启动线程、运行线程、删除 / 脱离线程。可以使用 rt_thread_create() 创建一个动态线程，使用 rt_thread_init() 初始化一个静态线程，动态线程与静态线程的区别是：动态线程是系统自动从动态内存堆上分配栈空间与线程句柄（初始化 heap 之后才能使用 create 创建动态线程)，静态线程是由用户分配栈空间与线程句柄。![04thread_ops](pic\04thread_ops.png)
  
- 创建和删除线程

  > 一个线程想要成为可执行的对象，就必须由操作系统内核来为它创建一个线程，可通过下面接口创建一个动态线程
  >
  > ~~~c
  > rt_thread_t rt_thread_create(const char* name,
  >                    void (*entry)(void* parameter),
  >                    void* parameter,
  >                    rt_uint32_t stack_size,
  >                    rt_uint8_t priority,
  >                    rt_uint32_t tick);
  > ~~~
  >
  > 调用这个函数时，系统会自动从动态堆内存中分配一个线程句柄按照参数中指定栈的大小从动态内存堆内存中分配相应的空间。分配出来的栈空间是按照 rtconfig.h 中配置的 RT_ALIGN_SIZE 方式对齐。线程创建 rt_thread_create() 的参数和返回值见下表：
  >
  > | 参数       | 描述                                                         |
  > | ---------- | ------------------------------------------------------------ |
  > | name       | 线程的名称；线程名称的最大长度由 rtconfig.h 中的宏 RT_NAME_MAX 指定，多余部分会被自动截掉 |
  > | entry      | 线程的入口函数                                               |
  > | parameter  | 线程的入口函数参数                                           |
  > | stack_size | 线程栈大小，单位是字节                                       |
  > | priority   | 线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0~255，数值越小优先级越高，0 代表最高优先级 |
  > | tick       | 线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行 |
  > | **返回** | —————— |
  > | thread | 线程创建成功，返回线程句柄 |
  > | RT_NULL | 线程创建失败 |
  >
  > 对于一些使用 rt_thread_create() 创建出来的线程，当不需要使用，或者运行出错时，我们可以使用下面的函数接口来从系统中把线程完全删除掉：
  >
  > ~~~c
  > rt_err_t rt_thread_delete(rt_thread_t thread);
  > ~~~
  >
  > 调用该函数后，对象线程将会被移除线程队列并且从内核对象管理器中删除，线程占用的堆栈空间也会被释放，收回的空间将重新用于其他的内次分配。实际上，用 rt_thread_delete() 函数删除线程接口，仅仅是把相应的线程状态更改为 RT_THREAD_CLOSE 状态，然后放入到 rt_thread_defunct 队列中；而真正的删除动作（释放线程控制块和释放线程栈）需要等到下一次执行空闲线程时，由空闲线程完成最后的线程删除动作。线程删除接口rt_thread_delete()接口的参数和返回值见下表：
  >
  > | 参数      | 描述         |
  > | --------- | ------------ |
  > | **返回**  | ---          |
  > | RT_EOK    | 删除线程成功 |
  > | -RT_ERROR | 删除线程失败 |
  >
  > > [!NOTE]
  > >
  > > 注：rt_thread_create() 和 rt_thread_delete() 函数仅在使能了系统动态堆时才有效（即 RT_USING_HEAP 宏定义已经定义了）。

- 初始化和脱离线程
  
  > 线程的初始化可以使用以下的函数接口来完成，来初始化线程对象：
  >
  > ~~~c
  > rt_err_t rt_thread_init(struct rt_thread* thread,
  >                const char* name,
  >                void (*entry)(void* parameter), void* parameter,
  >                void* stack_start, rt_uint32_t stack_size,
  >                rt_uint8_t priority, rt_uint32_t tick);
  > ~~~
  >
  > 静态线程的线程句柄（或者说线程控制块指针）、线程栈有用户提供。静态线程是之线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定，被分配处理、内核不负责动态分配内存空间。需要注意的是。用户提供的栈首地址需要做系统对齐（例如 ARM 上需要做 4 字节对齐）。线程初始化接口 rt_thread_init() 的参数和返回值见下表：
  >
  > | 参数        | 描述                                                         |
  > | ----------- | ------------------------------------------------------------ |
  > | thread      | 线程句柄，句柄由用户提供出来，并指向对应的线程控制块内存地址 |
  > | name        | 线程的名称；线程名称的最大长度由 rtconfig.h 中定义的 RT_NAME_MAX 宏指定，多余部分会被自动截掉 |
  > | entry       | 线程的入口函数                                               |
  > | parameter   | 线程的入口函数参数                                           |
  > | stack_start | 线程栈起始地址                                               |
  > | stack_size  | 线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐） |
  > | priority    | 线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级 |
  > | tick        | 线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行 |
  > | **返回**    | ——                                                           |
  > | RT_EOK | 线程创建成功 |
  > | -RT_ERROR | 线程创建失败 |
  >
  > 对于用 rt_thread_init() 初始化的线程，使用 rt_thread_detach() 将线程对象在线程队列和内核对象管理器中被脱离。线程脱离函数如下
  >
  > ~~~c
  > rt_err_t rt_thread_detach (rt_thread_t thread);
  > ~~~
  >
  > 线程脱离接口 rt_thread_detach() 的参数和返回值如下表
  >
  > | 参数      | 描述                                                       |
  > | --------- | ---------------------------------------------------------- |
  > | thread    | 线程句柄，它应该是由 rt_thread_init 进行初始化的线程句柄。 |
  > | **返回**  | ——                                                         |
  > | RT_EOK    | 线程脱离成功                                               |
  > | -RT_ERROR | 线程脱离失败                                               |
  >
  > 这个函数接口是和 rt_thread_delete() 函数相对应的， rt_thread_delete() 函数操作的对象是 rt_thread_create() 创建的句柄，而 rt_thread_detach() 函数操作的对象是使用 rt_thread_init() 函数初始化的线程控制块。同样，线程本身不应调用这个接口脱离线程本身。
  
- 启动线程

  > 创建（初始化）的线程状态处于初始状态，并未进入就绪线程的调度队列，我们可以在线程初始化 / 创建成功后调用下面的函数接口让该线程进入就绪态：
  >
  > ~~~c
  > rt_err_t rt_thread_startup(rt_thread_t thread);
  > ~~~
  >
  > 当调用这个函数时，将把线程的状态更改为就绪状态，并放到相应优先级队列中等待调度。如果新启动的线程优先级比当前线程优先级高，将立刻切换到这个线程。线程启动接口 rt_thread_startup() 的参数和返回值见下表：
  >
  > | **参数**  | **描述**     |
  > | --------- | ------------ |
  > | thread    | 线程句柄     |
  > | **返回**  | ——           |
  > | RT_EOK    | 线程启动成功 |
  > | -RT_ERROR | 线程启动失败 |
  >
  
- 获得当前线程

  > 在程序运行过程中，相同的一段代码可能会被多个线程执行，在执行的时候可以通过下面的接口函数接口获得当前执行的线程句柄：
  >
  > ~~~c
  > rt_thread_t rt_thread_self(void);
  > ~~~
  >
  > 该接口的返回值见下表
  >
  > | **返回** | **描述**             |
  > | -------- | -------------------- |
  > | thread   | 当前运行的线程句柄   |
  > | RT_NULL  | 失败，调度器还未启动 |

- 让线程让出处理器资源

  > 当前线程的时间片用完或者该线程主动要求让出处理器资源时，它将不再占有处理器，调度器会选择相同优先级的下一个线程执行。线程调用这个接口后，这个线程仍然在就绪队列中。线程让出处理器使用下面的函数接口：
  >
  > ~~~c
  > rt_err_t rt_thread_yield(void);
  > ~~~
  >
  > 调用该函数后，当前线程首先把自己从它所在的就绪优先级线程队列中删除，然后把自己挂到这个优先级队列链表的尾部，然后激活调度器进行线程上下文切换（如果当前优先级只有这一个线程，则这个线程继续执行，不进行上下文切换动作）
  >
  > > [!NOTE]
  > >
  > > rt_thread_yield() 函数和 rt_schedule() 函数比较相像，但在有相同优先级的其他就绪态线程存在时，系统的行为却完全不一样。执行 rt_thread_yield() 函数后，当前线程被换出，相同优先级的下一个就绪线程将被执行。而执行 rt_schedule() 函数后，当前线程并不一定被换出，即使被换出，也不会被放到就绪线程链表的尾部，而是在系统中选取就绪的优先级最高的线程执行（如果系统中没有比当前线程优先级更高的线程存在，那么执行完 rt_schedule() 函数后，系统将继续执行当前线程）

- 使线程睡眠

  > 在实际应用中，我们有时需要让运行的当前线程延迟一段时间，在指定的时间到达后重新运行，这就叫做 “线程睡眠”。线程睡眠可使用以下三个函数接口：
  >
  > ~~~c
  > rt_err_t rt_thread_sleep(rt_tick_t tick);
  > rt_err_t rt_thread_delay(rt_tick_t tick);
  > rt_err_t rt_thread_mdelay(rt_int32_t ms);
  > ~~~
  >
  > 这三个函数接口的作用相同，调用它们可以使当前线程挂起一段指定的时间，当这个时间过后，线程会被唤醒并再次进入就绪状态。这个函数接受一个参数，该参数指定了线程的休眠时间。线程睡眠接口 rt_thread_sleep/delay/mdelay() 的参数和返回值见下表：
  >
  > | **参数** | **描述**                                                     |
  > | -------- | ------------------------------------------------------------ |
  > | tick/ms  | 线程睡眠的时间： sleep/delay 的传入参数 tick 以 1 个 OS Tick 为单位 ； mdelay 的传入参数 ms 以 1ms 为单位； |
  > | **返回** | ——                                                           |
  > | RT_EOK   | 操作成功                                                     |
  >
  > 

