

## 嵌入式系统设计

### 一、概述

#### 1. 嵌入式系统概念

嵌入式系统是以应用为中心，以计算机技术为基础，且软硬件可裁剪，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统。 

1. 专用性：是专为目标对象设计定制的，与应用对象紧密结合，是面向用户
2. 嵌入性：是目标对象系统的组成部分，系统的软、硬件都嵌入到目标对象体系结构中，形成一个以计算技术、电子技术和特定的工程应用相结合的综合体
3. 计算机系统：是以计算机为基础，软、硬件可载减的专用计算机系统

####  2. 嵌入式系统组成

##### 1. 硬件层

   >硬件层包含：
   >
   >嵌入式微处理器: 嵌入式微控制器及其最小单元，如ARM、MIPS、 X86、 PowerPC和SH等 
   >
   >存储器（SDRAM、ROM、Flash等）
   >
   >- 用来存放程序（固化的应用软件）和数据（其他信息）
   >
   >  ROM：生成时固定不可再次编程只读，存放启动代码
   >
   >  **FLASH**：可读可写速度慢软件控制读写，存放断电保存数据
   >
   >  SRAM：速度快无需动态刷新体积大容量小价格高，Cache 
   >
   >  DRAM：体积小容量大价格低速度慢需控制器动态刷新，常用
   >
   >  **SDRAM**：时钟频率与处理器总线同步提高传输效率，最常用
   >
   >通用设备接口 A/D、D/A、RS-232、Ethernet、USB、IIS（音频 接口）、I2C、CAN、SPI和IrDA（红外线接口）等 
   >
   >嵌入式外围设备
   >
   >用于人机交互的设备：
   >
   >   ——LED、蜂鸣器、七段LED、LCD、…
   >
   >   ——按键、4*4键盘、拨盘、摇杆、触摸屏、…
   >
   >用于机机交互的设备：
   >
   >   ——传感器（Sensor）：温度传感器、压力传感器、…
   >
   >   ——伺服执行机构（Actuator）：继电器和电机、…

##### 2. 中间层-硬件适配层

   >在硬件层与软件层之间，也称为硬件抽象层（Hardware Abstract Layer，HAL）或板级支持包（Board Support Package，BSP）
   >
   >任务：相关底层硬件的初始化及配置，
   >
   >​     设备驱动程序 
   >
   >特点：
   >
   >① 硬件相关性，直接操作底层硬件。
   >
   >② 操作系统相关性： 为操作系统提供所需要的硬件操作接口。

   

##### 3. 系统软件层

   >系统软件层由嵌入式操作系统（EOS） 、文件系统、图形用户接口（GUI）、网络系统及通用组件模块等组成
   >
   >**引导程序**
   >
   >   一般由汇编语言编写，在嵌入式系统上电后运行，完成自检、存储映射、时钟系统和外设接口配置等硬件初始化操作。
   >
   >**应用程序**
   >
   >   一般由C语言编写，直接架构在硬件之上，在引导程序之后运行，负责实现嵌入式系统的主要功能。
   >
   >负责管理系统的硬件资源（如处理器、内存、输入输出设备等）和软件资源（如应用程序、驱动程序等），为上层应用提供多任务处理、内存管理、文件系统、设备驱动管理等功能。常见的嵌入式操作系统有 Linux、Windows Embedded、VxWorks、FreeRTOS 等。

##### 4. 功能层

   >基于操作系统开发的应用程序组成，用来完成对被控对象的控制功能 

#### 3. 嵌入式系统的特点

1. 技术先进。将先进的计算机技术、半导体技术以及电子技术与各个行业的具体应用相结合的产物（国内：龙芯、全志、华为海思等）

2. 系统内核小。一般是应用于电子装置中，系统资源相对有限。

3. 专用性强。软件和硬件结合非常紧密，应用具有一定的针对性。

4. 系统精简。一般没有系统软件和应用软件的明显区分，减少不需要的功能降低复杂度，提供系统安全性。 

5. 系统软件要求具有高实时性。且软件要求固态存储，以提高速度。

6. 嵌入式软件开发走向标准化，逐步形成丰富的可兼容的各种软件组件、函数库 等。

7. 嵌入式系统本身不具备在其上进行进一步开发的能力。用户如果需要修改其中的程序功能，需要借助于一套开发工具和环境。

#### 嵌入式系统开发过程

1. 包括 **需求分析、体系结构设计、软件设计、硬件设计、系统集成和系统优化与测试**6个阶段。
2. 包括 **嵌入式系统分析，嵌入式系统设计，嵌入式系统实现，嵌入式系统实现，嵌入式系统测试，嵌入式系统发布** 五个阶段

ps：这里有两套答案，我也不知道看哪个

### 二、ARM Cortex-M3内核

#### 1. arm分类

#### 2. arm内核

   - 32位的ARM指令集。

     >对应处理器状态：ARM状态、

   - 16位的Thumb指令集。

     >  对应处理器状态：Thumb状态

   > [!NOTE]
   >
   > 这两种指令集也对应了两种处理器执行状态<br>
   >
   > 在程序的执行过程中, 处理器可以动态地在两种执行状态之中切换。<br>
   >
   > 实际上，Thumb指令集在功能上是ARM指令集的一个子集，但它能带来更高的代码密度，给目标代码减肥。

#### 3. 工作模式

#####  (1) 指令集

- CICS: 复杂指令集 (Complex Instruction Set Computer)

  >1. 具有大量的指令和寻址方式
  >2. 8/2原则：80%的程序只使用20%的指令
  >3. 大多数程序只使用少量的指令就能够运行。

- RISC: 精简指令集 (Reduced Instruction Set Computer)

  > 1.  在通道中只包含最有用的指令
  > 2.  确保数据通道快速执行每一条指令
  > 3.  使CPU硬件结构设计变得更为简单

#####  (2) 流水线

> [!TIP]
>
> CPU中的流水线技术是一种将指令分解为多步，并让不同指令的各步操作重叠执行，从而实现几条指令并行处理，以加速程序运行过程的技术。
>
> ARM7采用三级流水线、ARM9采用五级流水线，ARM10采用六级流水线、ARM11采用八级流水线。



- **ARM7三级流水线工作**

  >1. 取指，从存储器中装载一条指令到CPU中
  >2. 解码，识别并解释将要被执行的指令
  >3. 执行，将解码识别的指令进行计算处理并将结果写回寄存器

![image-20250619230443149](./img/threestream.png)

##### (3) 处理器结构

- 哈佛结构

  > 哈佛结构是一种将程序中**指令和数据分开存储**的存储器结构。<br>
  >
  > 它是一种并行存储体系结构，程序存储器和数据存储器采用不同的总线，从而提供较大的存储器带宽


- 冯·诺伊曼结构
  
  >冯·诺伊曼结构也称普林斯顿结构，是一种将**程序指令存储器和数据存储器合并在一起的**存储器结构。<br>
  >
  >程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置。
  
> [!TIP]
>
> ARM7采用了普林斯顿结构，随后的ARM9、ARM10、ARM11、ARM Cortex等处理器采用了哈佛结构。 



##### (3) 总线规范

- AMBA (Advanced Microcontroller Bus Architecture) 总线规范是ARM公司设计的一种用于高性能嵌入式系统的总线标准

  >AMBA 2.0规范中定义了三种可以组合使用的不同类型的总线：
  >
  >AHB(Advanced High-performance Bus)、ASB(Advanced System Bus)\APB(Advanced Perpheral Bus)
  >
  >1. AHB总线适用于连接高性能和高时钟频率的系统模块 
  >2. ASB总线适用于连接高性能的系统模块。它的读/写数据总线采用的是同一条双向数据总线
  >3. APB总线适用于连接低功耗的外部设备模块



#### 4. Cortex M3内核

#####  (1) Cortex M3内核整体结构框架

1. 处理器核 (Processor Core System) —包括CPU和NVIC
2. 内存保护单元 (Memory Protection Unit--MPU)
3. 内部总线接口 (Bus Interconnect)
4. 为了方便调试和跟踪的可选的Debug System和Debug Intertface单元组成

##### (2) Cortex-M3内部结构

1. ALU
2. 寄存器组
3. 内建的嵌套向量中断控制器
4. CM3 采用了哈佛结构，拥有独立的指令总线和数据总线，可以让取指与数据访问并行进行
5. 比较复杂的应用可能需要更多的存储系统功能，为此CM3 提供一个可选的MPU，而且在需要的情况下也可以使用外部的cache。另外在CM3 中，小端模式和大端模式都是支持的。
6. CM3 内部还附赠了好多调试组件，用于在硬件水平上支持调试操作，如指令断点，数据观察点等。另外，为支持更高级的调试，还有其它可选组件，包括指令跟踪和多种类型的调试接口

##### (3) MPU概览

> 在Cortex‐M3处理器中可以**选配**一个存储器保护单元（MPU），它可以实施对存储器（主要是内存和外设寄存器）的保护，以使软件更加健壮和可靠。在使用前，必须根据需要对其编程。如果没有启用MPU，则等同于系统中没有配MPU。MPU有如下能力可以提高系统的可靠性：

1. 阻止用户应用程序破坏操作系统使用的数
2. 阻止一个任务访问其它任务的数据区，从而把任务隔开
3. 可以把关键数据区设置为只读，从根本上消除了被破坏的可能。检测意外的存储访问，如，堆栈溢出，数组越界

##### (4) Cortex-M3 的工作状态

> Cortex-M3 处理器有以下两种工作状态

1.  **Thumb状态** 这是16位和32位半字对齐的Thumb和Thumb-2指令的正常执行状态
2. **调试状态** 处理器停机调试的时候进入该状态 

> [!NOTE]
>
> 与ARM7处理器不同，Cortex-M3处理器不支持ARM指令的执行，也就没有ARM状态

##### (5) Cortex-M3的工作模式

> [!IMPORTANT]
>
> Cortex-M3 处理器支持两种工作模式 线程模式 (thread mode) 和 处理模式 (handler mode)

>在复位时，Cortex-M3 处理器进入线程模式，异常返回时也会进入该模式，特权和用户 (非特权) 代码能够在线程模式下运行。<br>
>
>出现异常时，Cortex-M3 处理器进入处理模式，在处理模式中，所有代码都是特权访问的

##### (6) Cortex-M3 代码的特权分级

> Cortex-M3的代码执行进行了特权分级，可以分为特权执行和非特权执行。特权执行时可以访问所有资源。非特权执行时对有些资源的访问受到限制或不允许访问
>
> 特权分级可以提供一种存储器访问保护机制，避免普通用户因程序代码出现意外而对存储器关键区域进行操作，这也是一种基本的安全模型
>
> 处理模式始终是特权访问，线程模式可以是特权访问，也可以是非特权访问

##### (7) 操作模式和特权级别

- **工作模式** 

  >实际上就是指Cortex-M3核当前的运行模式，有**线程模式**和**处理器模式**两种。若Cortex-M3核正在运行的是用户的应用程序，那么当前的操作模式就是线程模式；若Cortex-M3核正在运行的是异常（中断）服务程序，那么当前的操作模式就是处理器模式。

- **特权级别** 

  >指在当前操作模式下，程序代码对系统硬件资源访问和使用的优先级别，包括用户级和特权级两种。特权级能够使用所有的指令访问所有的资源。用户级不能执行特权级指令（如MSR/MRS），有限制的访问存储器和外围模块。引入用户级和特权级两级特权级别的目的，是为了提供一种存储器访问的保护机制，使得普通的用户程序代码不能意外地，甚至是恶意地执行涉及到要害的操作

##### (8) Cortex-M3的双堆栈机制

> Cortex-M3的程序存储使用堆栈来实现。整个系统提供一个主堆栈MSP(Main Stack Pointer)供用户程序和异常处理程序使用，每一个处于线程模式的程序也有一个自己的进程堆栈PSP(Process Stack Pointer)



##### (9) 寄存器阵列

- Cortex-M3 分类

~~~
├── 通用寄存器 (R0-R15)
│   ├── 低组寄存器 (R0-R7)
│   ├── 高组寄存器 (R8-R12)
│   ├── 堆栈指针寄存器 SP (R13)
│   ├── 链接寄存器 LR (R14)
│   └── 程序计数器 PC (R15)
│
└── 特殊功能寄存器
    ├── 程序状态寄存器 (xPSR) [三合一]
    │   ├── APSR
    │   ├── IPSR
    │   └── EPSR
    │
    ├── 中断屏蔽寄存器组
    │   ├── PRIMASK
    │   ├── FAULTMASK
    │   └── BASEPRI
    │
    └── 控制寄存器 (CONTROL)
~~~

> [!NOTE]
>
> - 通用目的寄存器R0-R7：R0‐R7 也被称为低组寄存器。所有指令都能访问它们。（绝大多数16 位指令只能使用R0‐R7） ，复位后的初值不确定；
>
> - 通用目的寄存器R8-R12：R8‐R12 也被称为高组寄存器。只有很少的16 位Thumb 指令能访问它们，32位的Thumb2指令则不受限制，复位后的初值不确定
>
> - 堆栈指针R13：R13 是堆栈指针。在CM3 处理器内核中共有两个堆栈指针，于是也就支持两个堆栈。
>
>   1. **主堆栈指针（MSP），**或写作SP_main。这是缺省的堆栈指针，它由OS 内核、异常服务例程以及所有需要特权访问的应用程序代码来使用
>
>   2. **进程堆栈指针（PSP）**，或写作SP_process。用于常规的应用程序代码
>
>      > [!NOTE]
>      >
>      > 并不是每个应用都必须用齐两个堆栈指针。简单的应用程序只使用MSP就够了。

- ARM Cortex-M3寄存器组





![cortex-m3寄存器组](.\img\cortex-m3寄存器组.png)

- 主堆栈和进程堆栈, R13，两个堆栈指针

  >[!IMPORTANT]
  >
  >1. Cortex-M3内核有两个堆栈指针：MSP和PSP
  >
  >2. 结束复位后，所有代码都使用主堆栈 
  >
  >3. 所有异常都使用主堆栈
  >
  >4. 异常处理程序（例如SVC）可以通过改变其在退出时使用的EXC_RETURN值来改变线程模式使用的堆栈。
  >
  >5. 在线程模式中，使用MSR指令对CONTROL[1]执行写操作也可以从主堆栈切换到进程堆栈
  >
  >6. 堆栈指针R13是分组寄存器，在SP_main和SP_process之间切换。任何时候，进程堆栈和主堆栈中只有一个是可见的，由R13指示

  > 通过MSR指令修改CONTROL[1]进行堆栈切换
  >
  > ![r13寄存器](.\img\r13寄存器.png)

- 堆栈寄存器

  > [!IMPORTANT]
  >
  > - 在Cortex‐M3 中，有专门的指令负责堆栈操作——PUSH 和POP。它俩的汇编语言语法如下例所演示：
  >
  >   ~~~assembly
  >   PUSH {R0}
  >   POP {R0}
  >   ~~~
  >
  > - 在程序中为了突出重点，可以使用SP 表示R13。在程序代码中，MSP 和PSP 都被称为R13/SP。不过，我们可以通过MRS/MSR 指令来指名道姓地访问具体的堆栈指针。
  >
  > - MSP，亦写作SP_main，这是复位后缺省使用堆栈指针，服务于操作系统内核和异常服务例程；而PSP，亦写作SP_process，典型地用于普通的用户线程中。
  >
  > - 通常在进入一个子程序后，第一件事就是把寄存器的值先PUSH 入堆栈中，在子程序退出前再POP 曾经PUSH 的那些寄存器。另外，PUSH 和POP 还能一次操作多个寄存器，如下所示：
  >
  >   ~~~assembly
  >   subroutine1
  >   	push {R0-R7, R12, R14}
  >   	...							;执行处理
  >   	pop {R0-R7, R12, R14}		;恢复寄存器列表
  >   	BX 14                       ;返回主函数
  >   ~~~
  >
  >   ![堆栈指针](.\img\堆栈指针.png)
  >
  > - 堆栈指针用于访问堆栈，并且PUSH指令和POP指令默认使用SP
  >
  >   >~~~assembly
  >   >;eg.
  >   >PUSH {R0}  		; *(--R13)=R0,R13是long*的指针（32位字长）
  >   >
  >   >POP  {R0} 		;R0=*R13++
  >   >
  >   >PUSH {R0}   	; *(--R13)=R0
  >   >
  >   >POP  {R0}		;R0=*R13++
  >   >
  >   >~~~
  
- Cortex-M3堆栈的实现与应用

  > 　 Cortex-M3使用的是“向下生长的满栈”模型。向下生长意味着堆栈规模向较低的地址空间扩大，栈顶SP的值在减小。满栈则是指堆栈指针 SP指向最后一个被压入堆栈的32位数值。在下一次压栈时，SP先自减 4，再存入新的数值。
  >
  >![堆栈地址](.\img\堆栈地址.png)
  >
  >- 堆栈指针的最低两位永远是0， 这意味着堆栈总是4字节对齐的-也就是说他们的地址必须是0x4,0x8,0xc,……。 事实上， R13的最低两位被硬线连接到 0，并且总是读出0

- 连接寄存器（LR）

  >[!NOTE]
  >
  >1. R14 是连接寄存器（LR）：用于在程序转移前保存当前的地址（系统自动完成），以便程序的返回（用户程序完成）。
  >2. 在一个汇编程序中，你可以把它写作 LR 或R14。LR 用于在调用子程序时存储返回地址。例如，当你在使用BL(分支并连接，Branch and Link)指令时，就自动填充LR 的值
  >
  >~~~assembly
  >main
  >	BL function1   		;使用分支连接 呼叫function1
  >						;PC = function1 并且 LR = main 的吓下一条指令
  >						
  >function1
  >	...
  >	BX LR				;函数返回，如果function要使用LR，必须在使用前PUSH
  >						;不然返回程序就跑飞了
  >~~~
  >
  >3. 与大多数其他处理器不同的是， ARM 为了减少访问内存的次数（访问内存的操作往往需要 3 个以上指令周期）， 把返回地址直接存储在寄存器中。 这样足以使很多只有 1 级子程序调用的代码， 在返回时无需访问堆栈内存， 从而提高了子程序调用的效率。 如果多于 1 级， 则需要把前一级的R14 值压入堆栈。 在 ARM 上编程时， 应尽量只使用寄存器保存中间结果， 迫不得已时才访问内存。

- 程序计数器  (R15)

  >- R15 是程序计数器，在汇编代码中你也可以使用名字“PC”来访问它。因为CM3 内部使用了指令流水线，读PC 时返回的值是当前指令的地址+4（+8？）。比如说：
  >
  >  >[!TIP]
  >  >
  >  >**可以通过直接给把R14（LR）寄存器的值送R15（PC），实现程序的返回**
  >
  > ~~~~assembly
  > 0x1000: MOV R0, PC ; R0 = 0x1004
  > ~~~~
>

- 特殊功能寄存器

  >Cortex‐M3 还在内核水平上搭载了若干特殊功能寄存器，包括:
  >
  >1. **程序状态字寄存器组**（PSRs或xPSR）
  >2. **中断屏蔽寄存器组**（PRIMASK, FAULTMASK, BASEPRI）
  >3. **控制寄存器**（CONTROL）
  >
  >它们只能被专用的MSR 和MRS 指令访问：
  >
  >~~~assembly
  >MRS <gp_reg>, <special_reg> 	;读特殊功能寄存器的值到通用寄存器
  >MSR <special_reg>, <gp_reg>	 ;写通用寄存器的值到特殊功能寄存器
  >~~~
  >
  >| 寄存器    | 功能                                                         |
  >| --------- | ------------------------------------------------------------ |
  >| xPSR      | 记录ALU标志（0标志，进位标志，负数标志，溢出标志），执行状态，以及当前正服务的中断号。 |
  >| PRIMASK   | 除能所有的中断——当然了，不可屏蔽中断（NMI）才不甩它呢。      |
  >| FAULTMASK | 除能所有的fault——NMI依然不受影响，而且被除能的faults会“上访”，见后续章节的叙述。 |
  >| BASEPRI   | 除能所有优先级不高于某个具体数值的中断。                     |
  >| CONTROL   | 定义特权状态（见后续章节对特权的叙述），并且决定使用哪一个堆栈指针。 |
  >
  >- 程序状态寄存器
  >
  >>程序状态寄存器在其内部又被分为三个子状态寄存器
  >
  >>1. 应用程序 PSR（APSR）
  >>2. 中断号 PSR（IPSR）
  >>3. 执行 PSR（EPSR）
  >
  >>通过MRS/MSR 指令，这3 个PSRs 既可以单独访问，也可以组合访问（2 个组合，3 个组合都可以）。当使用三合一的方式访问时，应使用名字“xPSR”或者“PSRs”。
  >
  >>xPSR、IPSR、EPSR寄存器只能在特权模式下被访问， APSR可以在特权或非特权（用户级）访问。
  >
  >>![程序状态寄存器](.\img\程序状态寄存器.png)
  >
  >>- xPSR标志位
  >
  >>| 标志位                                  | 含义                                                         |
  >>| --------------------------------------- | ------------------------------------------------------------ |
  >>| N-Negtive                               | 负数标志位。当算术运算或比较操作的结果为负数时，该位被置为 1；结果为非负数时，该位为 0。例如，在进行两个补码数的减法运算后，如果结果是负数，N 位就会被置 1。 |
  >>| Z-Zero                                  | 零标志位。当算术运算或比较操作的结果为 0 时，该位被置为 1；结果不为 0 时，该位为 0。比如，执行一个减法运算后，若差为 0，Z 位就会被置 1 |
  >>| C-Carry                                 | **四种方法设置**C的值：加法运算：当运算结果产生了进位时（无符号位溢出），C=1，否则C=0.减法运算：当运算时产生了借位时（无符号数溢出），C=0，否则C=1.对于包含移位操作的非加/减运算指令，C为移除值的最后一位。对于其他的非加/减运算指令，C的值通常不会改变 |
  >>| V-Overflow                              | 溢出标志位。在有符号整数的算术运算中，如果运算结果超出了有符号数所能表示的范围，该位被置为 1，否则为 0。例如，在进行两个有符号字节数相加，结果超出了 - 128 到 127 的范围时，V 位就会被置 1 |
  >>| Q-饱和标志，在实现DSP扩展的处理器中使用 | 在实现数字信号处理（DSP）扩展的处理器中使用，用于指示算术运算是否发生了饱和情况。当运算结果达到了可表示的最大值或最小值并不能再继续增大或减小（即发生饱和）时，Q 位被置 1。 |
  >>| ICI/IT                                  | \- **ICI**（Interrupt Controller Type）：与中断控制器相关，用于中断继续指令位。<br/>\- **IT**（Interrupt Type）：记录 IF-THEN 指令状态，用于条件执行，确保指令按预期逻辑执行。 |
  >>| T                                       | 当前运行的是 Thumb 指令集（恒为 1）。Thumb 是 ARM 指令集的压缩形式，代码密度高，适用于嵌入式系统。 |
  >>| Exception Number                        | \- **线程模式**：值为 0。<br/>\- **Handler 模式**：存放异常号（8 位，0~255），对应不同异常类型（如中断、复位、系统调用等），处理器据此调用相应异常处理程序。 |
  >
  >
  >- 中断屏蔽寄存器组
  >
  >>1. PRIMASK：（外部中断）关中断，中断屏蔽寄存器（相当于X86的IF）
  >>2. FAULTMASK：（内部中断）关异常，留给操作系统用。
  >>3. BASEPRI ：关闭优先级大于某值的中断（不响应优先级低的中断）
  >
  >>**只有在特权级下，才允许访问这3个寄存器。**
  >
  >>| 寄存器    | 功能描述                                                     |
  >>| --------- | ------------------------------------------------------------ |
  >>| PRIMASK   | 这是个只有1个位的寄存器。当它置1时，就关掉所有可屏蔽的异常，只剩下NMI和硬fault可以响应。它的缺省值是0，表示没有关中断。 |
  >>| FAULTMASK | 这是个只有1个位的寄存器。当它置1时，只有NMI才能响应，所有其它的异常，包括中断和fault，通通闭嘴。它的缺省值也是0，表示没有关异常。 |
  >>| BASEPRI   | 这个寄存器最多有9位（由表达优先级的位数决定）。它定义了被屏蔽优先级的阈值。当它被设成某个值后，所有优先级号大于等于此值的中断都被关（优先级号越大，优先级越低）。但若被设成0，则不关闭任何中断，0也是缺省值。 |
  >
  >>~~~assembly
  >>; CM3处理器快速中断控制指令集
  >>; 语法格式：CPS<effect> <iflags>
  >>; 1. 关闭所有可屏蔽中断（设置PRIMASK）
  >>CPSID I     ; PRIMASK = 1，关中断
  >>; 2. 开启所有可屏蔽中断（清除PRIMASK） 
  >>CPSIE I     ; PRIMASK = 0，开中断
  >>; 3. 关闭所有异常（包括fault，设置FAULTMASK）
  >>CPSID F     ; FAULTMASK = 1，关异常
  >>; 4. 开启所有异常（清除FAULTMASK）
  >>CPSIE F     ; FAULTMASK = 0，开异常
  >>
  >- CONTROL 寄存器
  >
  >> 用于控制和确定处理器的工作模式以及当前执行任务的特性
  >
  >> 以下是提取自图片的表格内容：
  >
  >> | 位         | 功能说明                                                     |
  >> | ---------- | ------------------------------------------------------------ |
  >> | CONTROL[1] | **堆栈指针选择**  • 0 = 主堆栈指针 MSP（复位缺省值）  • 1 = 进程堆栈指针 PSP    *使用规则：*  - 线程模式或基础级（非异常响应时）可使用PSP  - Handler模式下强制使用MSP（禁止写1） |
  >> | CONTROL[0] | **特权级别控制**  • 0 = 特权级线程模式  • 1 = 用户级线程模式    *补充说明：*  - Handler模式始终为特权级 |
  >
  >> 1. 当处理器处在**线程状态下**时，既可以使用特权级，也可以使用用户级；另一方面，**handler****模式**总是特权级的。在复位后，处理器进入线程模式＋特权级。
  >> 2. 在线程模式＋用户级下，对系统控制空间（SCS）的访问将被阻止——该空间包含了配置寄存器 以及调试组件的寄存器s。除此之外，还禁止使用MSR 访问特殊功能寄存器——除了APSR 有例外。谁若是以身试法，则将fault 伺候。
  >> 3. 在特权级下的代码可以通过置位CONTROL[0]来进入用户级。而不管是任何原因产生了任何异常，处理器都将以特权级来运行其服务例程，异常返回后将回到产生异常之前的特权级。用户级下的代码不能再试图修改CONTROL[0]来回到特权级。它必须通过一个异常handler，由那个异常handler来修改CONTROL[0]，才能在返回到线程模式后拿到特权级。
  >
  >![状态转移图](.\img\状态转移图.png)

#####  (10) 异常和中断

- ARM Cortex-M3异常处理

> 1. 当正常的程序执行流程发生暂时停止时，称之为异常。
>
> 2. 例如，处理一个外部的中断请求，系统执行完当前执行的指令后可以转去执行异常处理程序。在处理异常之前，当前处理器的状态必须保留，这样当异常处理完成之后，当前程序可以继续执行。
>
> 3. 处理器允许多个异常同时发生，它们将会按固定的优先级进行处理。
> 4. Cortex-M3内核的异常响应系统，支持为数众多的系统异常和外部中断。
> 5. 其中，编号为1～15的对应系统异常，大于等于16的则全是外部中断。
> 6. 除了个别异常的优先级被定死外，其它异常的优先级都是可编程的。
> 7. 由于芯片设计者可以修改Cortex-M3的硬件描述源代码，所以做成芯片后支持的中断源数目常常不到240个，并且优先级的位数也由芯片厂商最终决定。

- NVIC管理的中断来自两个方面

  1.  **(内部中断)** 一个是来自Cortex M3处理器核内部的系统异常，系统异常是与处理器同步的事件，通常来自确定的内部错误，如指令执行了除0这样的非法操作，或者访问被禁的内存区间等
  2.  **(外部中断)** 另一类来自处理器外部的外设产生的中断。为了方便起见，后续将内部产生的系统异常中断称为内部中断，而由外部外设产生的中断称为外部中断

- 异常类型号表

  >Cortex‐M3 支持大量异常，包括16‐4‐1= 11 个系统异常，和最多240 个外部中断—简称IRQ，共256个中断（含异常）
  >
  >---与X86对中断的管理类似了！
  >
  >---通过向量表提供入口地址。
  >
  >| 编号 | 类型              | 优先级   | 简介                                                         |
  >| ---- | ----------------- | -------- | ------------------------------------------------------------ |
  >| 0    | N/A               | N/A      | 没有异常在运行                                               |
  >| 1    | 复位              | -3(最高) | 复位                                                         |
  >| 2    | NMI               | -2       | 不可屏蔽中断(来自外部 NMI 输入脚)                            |
  >| 3    | 硬(hard) fault    | -1       | 所有被除能的 fault，都将“上访”成硬 fault。除能的原因包括当前被禁用，或者 FAULTMASK 被置位。 |
  >| 4    | MemManage         | 可编程   | 存储器管理 fault，MPU 访问犯规以及访问非法位置均可引发。企图在“非执行区”取指也会引发此 fault |
  >| 5    | 总线 fault        | 可编程   | 从总线系统收到了错误响应，原因可以是预取流产(Abort)或数据流产，或者企图访问协处理器 |
  >| 6    | 用法(usage) fault | 可编程   | 由于程序错误导致的异常。通常是使用了一条无效指令，或者是非法的状态转换，例如尝试切换到 ARM 状态 |
  >| 7-10 | 保留              | N/A      | N/A                                                          |
  >| 11   | SVCall            | 可编程   | 执行系统服务调用指令(SVC)引发的异常                          |
  >| 12   | 调试监视器        | 可编程   | 调试监视器(断点，数据观察点，或者是外部调试请求)             |
  >| 13   | 保留              | N/A      | N/A                                                          |
  >| 14   | PendSV            | 可编程   | 为系统设备而设的“可悬挂请求”(pendable request)               |
  >| 15   | SysTick           | 可编程   | 系统滴答定时器(周期性溢出的时基定时器)                       |
  >| 16   | IRQ #0            | 可编程   | 外中断#0                                                     |
  >| 17   | IRQ #1            | 可编程   | 外中断#1                                                     |
  >| ...  | ...               | ...      | ...                                                          |
  >| 255  | IRQ #239          | 可编程   | 外中断#239                                                   |
  >
  >**分类标注**：
  >- 内部异常（编号0-15）
  >- 外部中断（编号16-255）

- 异常向量

  >| 异常类型 | 表项地址偏移量 | 异常向量        |
  >| -------- | -------------- | --------------- |
  >| 0        | 0x00           | MSP的初始值     |
  >| 1        | 0x04           | 复位            |
  >| 2        | 0x08           | NMI             |
  >| 3        | 0x0C           | 硬fault         |
  >| 4        | 0x10           | MemManage fault |
  >| 5        | 0x14           | 总线fault       |
  >| 6        | 0x18           | 用法fault       |
  >| 7-10     | 0x1C-0x28      | 保留            |
  >| 11       | 0x2C           | SVC             |
  >| 12       | 0x30           | 调试监视器      |
  >| 13       | 0x34           | 保留            |
  >| 14       | 0x38           | PendSV          |
  >| 15       | 0x3C           | SysTick         |
  >| 16       | 0x40           | IRQ #0          |
  >| 17       | 0x44           | IRQ #1          |
  >| 18-255   | 0x48-0x3FF     | IRQ #2 - #239   |
  >
  >eg. 举个例子，如果发生了异常11（SVC），则NVIC 会计算出偏移量是11x4=0x2C，然后从那里取出服务例程的入口地址并跳入。0 号异常的功能则是个另类，它并不是什么入口地址，而是给出了复位后MSP 的初值。
  >
  >- 当一个发生的异常被CM3 内核接受，对应的异常handler 就会执行。为了决定handler 的入口地址，CM3 使用了“向量表查表机制”。这里使用一张向量表。向量表其实是一个WORD（32 位整数）数组，每个下标对应一种异常，该下标元素的值则是该异常handler 的入口地址。向量表的存储位置是可以设置的，通过NVIC 中的一个重定位寄存器来指出向量表的地址。在复位后，该寄存器的值为0。因此，在地址0 处必须包含一张向量表（00000000-00003ffH，1K个单元），用于初始时的异常分配。

- 系统复位

  >- CPU核复位后，Cortex-M3 处理器会从存储器中读取下列两个 32 位整数值
  >- 从地址 0ｘ00000000 处取出R13(MSP）的初始值
  >- 从地址 0ｘ00000004 处取出 PC 初始值。这个值是复位向量，即程序执行的起始地址，LSB 必须是 1，以表明是 Thumb 状态
  >- ![复位过程](.\img\复位过程.png)
  >
  >> [!NOTE]
  >> 请注意，这与传统的ARM 架构不同——其实也和绝大多数的其它单片机不同。传统的ARM 架构总是从0 地址开始执行第一条指令。它们的0 地址处总是一条跳转指令。在CM3中，0 地址处提供MSP 的初始值，然后就是向量表（向量表在以后还可以被移至其它位置）。向量表中的数值是32 位的地址，而不是跳转指令。向量表的第一个条目指向复位后应执行的第一条指令。
  >
  >- MSP
  >
  >>1. 因为CM3 使用的是向下生长的满栈，所以MSP 的初始值必须是堆栈内存的末地址加1。举例来说，如果你的堆栈区域在0x20007C00‐0x20007FFF 之间，那么MSP 的初始值就必须是0x20008000。
  >>2. 向量表跟随在MSP 的初始值之后——也就是第2 个表目。要注意因为CM3 是在Thumb态下执行，所以向量表中的每个数值都必须把LSB 置1（也就是奇数）。正是因为这个原因，右图 中使用0x101 来表达地址0x100。当0x100 处的指令得到执行后，就正式开始了程序的执行。
  >>     ![初始化msp以及pc](.\img\初始化msp以及pc.png)

- 异常优先级

  >1. 在Cortex-M3中，优先级对于异常来说是很关键的，它会决定一个异常是否能被掩蔽，以及在未掩蔽的情况下何时可以响应。优先级的数值越小则优先级越高
  >
  >2. Cortex-M3支持中断嵌套，使得高优先级异常会抢占(preempt)低优先级异常
  >3. Cortex-M3有3个系统异常：复位、NMI以及硬故障。它们有固定的优先级并且优先级号是负数，从而高于所有其它异常

- 中断/异常的相应序列

  >- 中断是一种异常，异常基本上以中断为主，所以如果没有特殊说明，两个名词可以互换使用
  >
  >- 当Cortex-M3开始响应一个中断时，会产生三个动作
  >
  >  1. 入栈，把8个寄存器的值压入堆栈
  >  2. 取向量，从向量表中找出对应的服务程序入口地址
  >  3. 选择堆栈指针MSP/PSP，更新堆栈指针SP、连接寄存器LR及程序计数器PC
  >
  >  - 入栈
  >
  >    > 响应异常的第一个行动，就是自动保存现场的必要部分：依次把xPSR、PC、LR、R12以及R3～R0由硬件自动压入适当的堆栈中。当响应异常，当前的代码正在使用PSP时，压入PSP，也就是使用进程堆栈；否则就压入MSP，使用主堆栈。一旦进入了服务例程，就将一直使用主堆栈。所有的嵌套中断都使用主堆栈
  >
  >  - 取向量
  >
  >    >当数据总线(系统总线)正在为入栈操作而忙碌时，指令总线(I-Code总线)也在为响应中断紧张有序地执行另一项重要的任务，即从向量表中找出正确的异常向量(服务程序的入口地址)，然后在服务程序的入口处预取指。
  >    >
  >    > 由此可以看到各自都有专用总线的好处：入栈与取指这两个工作能同时进行。
  >
  >  - 更新寄存器  执行服务程序之前，还要更新以下一系列寄存器
  >
  >    >SP。入栈后会把堆栈指针(PSP或MSP)更新到新的位置。在执行服务程序时，将由MSP负责对堆栈的访问。
  >    >
  >    >PSR。更新IPSR位段(地处PSR的最低部分)的值为新响应的异常编号。
  >    >
  >    >PC。在取向量完成后，PC将指向服务程序的入口地址。    
  >    >
  >    >LR。在出入ISR时，LR的值将得到重新的诠释，这种特殊的值称为EXC_RETURN，在异常进入时由系统计算并赋给LR，并在异常返回时使用它。EXC_RETURN的二进制值除了最低4位外全为1，而其最低4位有另外的含义。
  >
  >- 异常返回
  >
  >  >1. 当异常服务程序执行完毕后，需要很正式地做一个“异常返回”动作序列，从而恢复先前的系统状态，才能使被中断的程序得以继续执行
  >  >
  >  >2. 从形式上看，有3种途径可以触发异常返回序列，分别是使用指令BX、POP和LDR。不管使用哪一种指令，都需要用 到先前存储到LR的EXC_RETURN
  >  >3.  Cortex-M3通过将EXC_RETURN写入PC来识别返回动作。因此，可以使用上述的常规返回指令，从而为使用C语言编写服务程序扫清最后的障碍(无需特殊的编译器命令，如_interrupt)
  >  >
  >  >在启动了中断返回序列后，将进行下述处理：
  >  >
  >  >1. 出栈
  >  >
  >  >   先前压入栈中的寄存器在这里恢复。内部的出栈顺序与入栈时的相对应，堆栈指针的值也改回先前的值。
  >  >
  >  >2. 更新NVIC寄存器
  >  >
  >  >   伴随着异常的返回，它的活动位也被硬件清除。对于外部中断，倘若中断输入再次被置为有效，挂起位也将再次置位，新一次的中断响应序列也可随之再次开始。
  >  >
  >  >  

##### (11) 存储器系统

- 概述

  > Cortex-M3 是一个32位处理器，支持4GB存储空间，特点：
  >
  > 1. Cortex-M3的存储器映射和总线配置是预定义了的， 并且还规定好了哪个位置使用哪条总线， 这个特性使得在访问不同的设备时， 处理器可以对这些访问进行优化
  >
  > 2. Cortex-M3的存储器系统支持“位带”操作， 可以实现对某些特殊存储器区域或外设中的位数据进行操作
  >
  > 3. CM3 存储器系统还支持非对齐访问和互斥访问， 这个特性也是 v7-M 架构的一部分
  >
  > 4. Cortex-M3 的存储器系统支持小端配置和大端配置
  >
  > 5. 比较复杂的应用可能需要更多的存储系统功能， 为此 Cortex-M3提供了一个可选的MPU， 而且在需要的情况下也可以使用外部的 Cache
  >
  >    ![地址映射](.\img\地址映射.png)
  >
  >    清晰一点的图片
  >
  >    ![地址分布](.\img\地址分布.png)
  >
  >    | 存储器区域 | 地址范围            | 用户级许可权限                                               |
  >    | ---------- | ------------------- | ------------------------------------------------------------ |
  >    | 代码区     | 0000_0000-1FFF_FFFF | 无限制                                                       |
  >    | 片内 SRAM  | 2000_0000-3FFF_FFFF | 无限制                                                       |
  >    | 片上外设   | 4000_0000-5FFF_FFFF | 无限制                                                       |
  >    | 外部 RAM   | 6000_0000-9FFF_FFFF | 无限制                                                       |
  >    | 外部外设   | A000_0000-DFFF_FFFF | 无限制                                                       |
  >    | ITM        | E000_0000-E000_0FFF | 可以读。对于写操作，除了用户级下允许时的stimulus端口外，全部忽略 |
  >    | DWT        | E000_1000-E000_1FFF | 阻止访问，访问会引发一个总线 fault                           |
  >    | FPB        | E000_2000-E000_3FFF | 阻止访问，访问会引发一个总线 fault                           |
  >    | NVIC       | E000_E000-E000_EFFF | 阻止访问（例外：软件触发中断寄存器可被编程为允许用户级访问），否则引发总线 fault |
  >    | 内部 PPB   | E000_F000-E003_FFFF | 阻止访问，访问会引发一个总线 fault                           |
  >    | TPIU       | E004_0000-E004_0FFF | 阻止访问，访问会引发一个总线 fault                           |
  >    | ETM        | E004_1000-E004_1FFF | 阻止访问，访问会引发一个总线 fault                           |
  >    | 外部 PPB   | E004_2000-E004_2FFF | 阻止访问，访问会引发一个总线 fault                           |
  >    | ROM 表     | E00F_F000-E00F_FFFF | 阻止访问，访问会引发一个总线 fault                           |
  >    | 供应商指定 | E010_0000-FFFF_FFFF | 无限制                                                       |
  >
  >    - 说明
  >
  >      >1.代码区（0x00000000~0x1FFFFFFF,512MB）
  >      >
  >      >​    主要用于存放程序代码。
  >      >
  >      >2.内部SRAM区（0x20000000~0x3FFFFFFF,512MB）
  >      >
  >      >​    （1）最底部1MB地址范围是“位带区”可存放8M个位（bit）变量；
  >      >
  >      >​     （2）32MB的“位带别名区”，用一个字（4字节）来代表每一个位带区的每一个位；
  >      >
  >      >​     （3）位带操作只适用于数据访问，不适用于取指；
  >      >
  >      >​     （4）消灭了传统的“读-改-写”三步曲以及由此产生的被中断的可能，可以显著提高位操作的效率和安全性。
  >      >
  >      >3、片内外设区（ 0x40000000~0x5FFFFFFF,512MB 
  >      >
  >      >​    （1）用于映射外设芯片的寄存器，主要由片内外设使用；
  >      >
  >      >​    （2）最低位1MB地址范围是“位带区”，可存放8M个位变量；
  >      >
  >      >​     （3）32MB的“位带别名区”，以便与快捷地访问外设寄存器；
  >      >
  >      >​     （4）该外设区内不允许执行指令。
  >      >
  >      >4.外部RAM区（0x60000000~0x9FFFFFFF,1GB）
  >      >
  >      >​    （1）外部RAM区用于连接外部RAM；
  >      >
  >      >​    （2）外部RAM区允许执行指令。
  >      >
  >      >5. 外部设备区（0xA0000000~0xDFFFFFFF,1GB）
  >      >
  >      >​    （1）外部设备区用于连接外部设备；
  >      >
  >      >​    （2）外部设备区不允许执行指令。
  >      >
  >      >6.私有外设总线区（ 0xE0000000~0xE00FFFFF,1MB ）
  >      >
  >      >​     （1）内部私有外设总线区（256KB）
  >      >
  >      >​     （2）外部私有外设总线区（768KB）
  >      >
  >      >![地址细分](.\img\地址细分.png)
  >      >
  >      >7.提供商指定区( 0xE0100000~0xFFFFFFFF，511MB )
  >      >
  >      >   （1）未用的存储器区域，由产品提供商指定。
  >      >
  >      >   （2）不允许在其中执行指令。

- 位带操作

  - 概述

    >1. 嵌入式系统中的位带（Bit-Band）操作指的是通过位带区域或者位带别名区域，快速定位和修改单个位的值。在嵌入式系统中，使用位带操作可以实现对硬件寄存器的控制、状态检测和处理，从而完成各种任务和功能。
    >2. 在传统的嵌入式系统中，要修改或读取一个寄存器中的某个位，需要通过移位运算、与运算等方式来实现。这样的方式不仅代码复杂，而且运算消耗资源，影响系统性能。而通过
    >3. 使用位带操作，可以将每个位映射到一个独立的内存地址上，直接操作特定的位，而无需使用位操作指令。这种方式既简单易懂，又能提高代码的可读性和简化操作，同时还能优化对特定位的访问性能。
    >4. 使用位带操作通常需要硬件支持，例如Cortex-M3处理器的地址空间中，就预留了位带区域和位带别名区域来支持位带操作。通过使用位带操作，可以方便地控制外设寄存器位的操作、处理中断状态和触发条件，实现系统功能的高效实现和调试

  - 位带地址

    > 在CM3中，有两个区中实现了位带。其中一个是SRAM区的最低1MB范围，第二个则是片内外设区的最低1MB范围。这两个位带中的地址除了可以像普通的RAM一样使用外，它们还都有自己的“位带别名区”，位带别名区把每个比特膨胀成一个32位的字。通过位带别名区访问这些字时，就可以达到访问原始比特的目的。
    >
    > ![位带地址](.\img\位带地址.png)
    >
    > 0x20000000-0x200FFFFF映射的别名地址为0x22000000-0x23FFFFFF
    >
    > 0x40000000-0x400FFFFF映射的别名地址为0x42000000-0x43FFFFFF
    >
    > - 1MB对应要操作的二进制位为8M个
    > - 每个位用一个32位的二进制字表示，对应膨胀区为8M4=32个单元
    >
    > ![位带膨胀](.\img\位带膨胀.png)
    >
    > - 在位带区中，每个比特都映射到别名地址区的一个字——这是个只有LSB才有效的字。当一个别名地址被访问时，会先把该地址变换成位带地址。对于读操作，读取位带地址中的一个字，再把需要的位右移到LSB，并把LSB返回。对于写操作，把需要写的位左移至对应的位序号处，然后执行一个原子的“读－改－写”过程
    >
    > > [!IMPORTANT]
    > >
    > > 支持位带操作的两个内存区的范围是：
    > >
    > > 0x2000_0000-0x200F_FFFF（SRAM区中的最低1MB）
    > >
    > > 0x4000_0000-0x400F_FFFF（片上外设区中的最低1MB）
    > >
    > > 对于SRAM位带区的某个比特，记它所在字节地址为A,位序号为n(0<=n<=7)，则该比特在别名区的地址为：
    > >
    > > AliasAddr＝ 0x22000000+((A-0x20000000)*8+n)*4 =0x22000000+ (A-0x20000000)*32 + n*4 
    > >
    > > 对于片上外设位带区的某个比特，记它所在字节的地址为A,位序号为n(0<=n<=7)，则该比特在别名区的地址为：
    > >
    > > AliasAddr＝ 0x42000000+((A-0x40000000)*8+n)*4 =0x42000000+ (A-0x40000000)*32 + n*4 
    > >
    > > 上式中，“*4”表示一个字为4个字节，“*8”表示一个字节中有8个比特。
    >
    > - 位带操作优点
    >
    >   1. **方便对接口器件的操作**，尤其是对硬件I/O密集型的底层程序，GPIO接口的位控制。
    >
    >   2. **简化跳转的判断**。当跳转依据是某个位时，传统做法是：读取整个寄存器；  屏蔽不需要的位；比较并跳转
    >
    >      而位带绑定使得代码更为简洁 从位带别名区读取状态位； 比较并跳 转
    >   3. **并发控制。**通过不同任务对共享资源的互斥访问，实现并发任务的串行化调度，保证并发任务的原子性、隔离性和被操作数据的一致性，避免出现紊乱现象。 
    >
  
- 存储格式
  
  >- 存储器字对齐
  >>32位字对齐指存储字地址的最末2位二进制位为00（字地址为4的整数倍
  >>![字对其1](.\img\字对其1.png)
  >>32位半字对齐指存储字地址的最末1位二进制位为0（半字地址为偶数）
  >>![字对其2](.\img\字对其2.png)
  >>字对齐时，读写一个字需要一个机器周期
  >- 存储器非字对齐
  >>任何一个不能被4整除的地址都是非对齐的。而对于半字，任何不能被2整除的地址（也就是奇数地址）都是非对齐的：
  >>![非字对齐](.\img\非字对齐.png)
  >
  >- 存储器非字对齐数据传送
  >
  >  >在CM3中，非对齐的数据传送只发生在常规的数据传送指令中，如LDR/LDRH/LDRSH。
  >  >
  >  >
  >  >
  >  >其它指令则不支持，包括：
  >  >
  >  >**(必须字对齐的操作)**
  >  >
  >  >1. 多个数据的加载/存储(LDM/STM)
  >  >
  >  >2. 堆栈操作PUSH/POP 
  >  >
  >  >3. 互斥访问(LDREX/STREX)。如果非对齐会导致一个用法fault
  >  >
  >  >4. 位带操作。因为只有LSB有效，非对齐的访问会导致不可预料的结果。
  >  >
  >  >非对齐存储器访问需要多个周期
  >
  
- 数据存储的端模式

  >- **小端格式（Cortex-M3默认）intel处理器**
  >
  >  小端格式，又称小字节序或者低字节序，是一种将高字节数据存放在高地址、低字节数据存放在低地址的存储格式（“高高低低”）
  >
  >  ![小端存储样例](.\img\小端存储样例.png)
  >
  >| 地址, 长度   | Bits 31-24 | Bits 23-16 | Bits 15-8 | Bits 7-0 |
  >| ------------ | ---------- | ---------- | --------- | -------- |
  >| 0x1000, 字   | D[31:24]   | D[23:16]   | D[15:8]   | D[7:0]   |
  >| 0x1000, 半字 |            |            | D[15:8]   | D[7:0]   |
  >| 0x1002, 半字 | D[15:8]    | D[7:0]     |           |          |
  >| 0x1000, 字节 |            |            |           | D[7:0]   |
  >| 0x1001, 字节 |            |            | D[7:0]    |          |
  >| 0x1002, 字节 |            | D[7:0]     |           |          |
  >| 0x1003, 字节 | D[7:0]     |            |           |          |
  >
  >- 大端格式 (Motorola、IBM处理器)
  >
  >  ​    大端格式，又称大字节序或者高字节序，是一种将高字节数据存放在低地 址、低字节数据存放在高地址的存储格式（“高低低高”）。例如，在下图的存储分布中，使用大端格式读取地址0x20009FFC上的字数据为0x0A9B000C。
  >
  >  ![大段存储样例](.\img\大段存储样例.png)
  >
  >- 总结
  >
  >  >Cortex-M3在复位时确定使用哪种“端模式”，且运行时不得更改，一般默认小端模式。
  >  >
  >  >指令预取永远使用小端模式，在配置控制存储空间的访问也永远使用小端模式(包括NVIC, FPB之流)。
  >  >
  >  >另外，私有外设总线区0xE000_0000至0xE00F_ FFFF也永远使用小端模式。
  >  >
  >  >针对采用大端模式工作的外设时，可以使用REV/REVH指令来完成端模式的转换。
  

#### 三、 ARM汇编

##### 1. Cortex M3 指令系统

eg. ![汇编样例](.\img\汇编样例.png)

###### (1) 语句格式

~~~assembly
;标号 	    操作码	目的操作数（Rd）, 源操作数1(Rn), 源操作数2(Rm)    ; 注释
~~~

>- **标号**       标号是可选的，如果有，**它必须顶格写**。标号的作用是让汇编器来计算程序转移的地址。
>- **操作码**    操作码是指令的助记符，说明指令的功能，必须有。**它的前面必须有至少一个空白符**，通常使用一个“Tab”键来产生。
>- **操作数**    指令处理的对象。操作码后面往往跟随若干个操作数，而第1 个操作数，通常都给出本指令执行结果的存储地。不同指令需要不同数目的操作数，并且对操作数的语法要求也不同。通常目的操作数和源操作数1都是寄存器寻址方式，源操作数2可以是立即数、寄存器或寄存器移位等。
>- **注释**      注释均以“;”开头，它的有无不影响汇编操作，只是给程序员看的，能让程序更易理解

###### (2) 统一汇编语言

>- 为了最有力地支持Thumb‐2，引了一个“统一汇编语言（UAL）”语法机制。对于16 位指令和32 位指令均能实现的一些操作（常见于数据处理操作），有时虽然指令的实际操作数不同，或者对立即数的长度有不同的限制，但是汇编器允许开发者以相同的语法格式书写，并且由汇编器来决定是使用16 位指令，还是使用32 位指令。以前，Thumb 的语法和ARM的语法不同，在有了UAL 之后，两者的书写格式就统一了。
>
>~~~assembly
> ADD  R0, R1 ; 传统的Thumb 语法
>
> ADD  R0, R0, R1 ; UAL 语法允许的等值写法（R0=R0+R1）
>~~~
>
>- 虽然引入了UAL，但是仍然允许使用传统的Thumb 语法。不过有一项必须注意：如果使用传统的Thumb 语法，有些指令会默认地更新APSR，即使你没有加上S 后缀。如果使用UAL 语法，则必须指定S 后缀才会更新。
>
> ~~~assembly
>  AND  R0, R1 ;传统的Thumb 语法
>
>  ANDS  R0, R0, R1 ;等值的UAL 语法（必须有S 后缀）
> ~~~
>
>- 在Thumb‐2 指令集中，有些操作既可以由16 位指令完成，也可以由32 位指令完成。
>
>  ​    
>
>  例如，R0=R0+1 这样的操作，16 位的与32 位的指令都提供了助记符为“ADD”的指令。在UAL 下，你可以让汇编器决定用哪个，也可以手工指定是用16 位的还是32 位的：
>
>  ~~~assembly
>ADDS  R0, #1 ;汇编器将为了节省空间而使用16 位指令
> ADDS.N  R0, #1 ;指定使用16 位指令（N＝Narrow）
>ADDS.W  R0, #1 ;指定使用32 位指令（W=Wide）
>  ~~~
>
>  ​    .W(Wide)后缀指定32 位指令。如果没有给出后缀，汇编器会先试着用16 位指令以缩小代码体积，如果不行再使用32 位指令。因此，使用“.N”其实是多此一举，不过汇编器可能仍然允许这样的语法。
>
> 再次重申，这是ARM 公司汇编器的语法，其它汇编器的可能略有区别，但如果没有给出后缀，汇编器就总是会尽量选择更短的指令。

######  (3) 指令后缀

>在 ARM 处理器中，指令可以带以下两类后缀：
>
>- 执行指令后设置程序状态寄存器APSR相关状态位的指令后缀S
>
>     例如： ADDS  R0, R1  ; 根据相加的结果更新APSR 中的标志
>
>- 有条件执行指令的指令后缀：
>
>     EQ=Euqal, NE= Not Equal, LT= Less Than, GT= Greater Than等，共定义了16种不同的条件后缀，见下表。
>
>    例如：BEQ <Label> ; 仅当EQ 满足时转移
>
>说明
>
>- 而对于其它指令，CM3 引入了IF‐THEN 指令块，在这个块中才可以加后缀，且必须加后缀。IF‐THEN 块由IT 指令定义，详见后续介绍。
>
>- 另外，S 后缀可以和条件后缀在一起使用。
>
>| 操作码 | 条件助记符 | 标志位条件 | 含义说明                   |
>| ------ | ---------- | ---------- | -------------------------- |
>| 0000   | EQ         | Z=1        | 相等                       |
>| 0001   | NE         | Z=0        | 不相等                     |
>| 0010   | CS/HS      | C=1        | 无符号数大于或等于         |
>| 0011   | CC/LO      | C=0        | 无符号数小于               |
>| 0100   | MI         | N=1        | 负数                       |
>| 0101   | PL         | N=0        | 正数或零                   |
>| 0110   | VS         | V=1        | 溢出                       |
>| 0111   | VC         | V=0        | 没有溢出                   |
>| 1000   | HI         | C=1,Z=0    | 无符号数大于               |
>| 1001   | LS         | C=0,Z=1    | 无符号数小于或等于         |
>| 1010   | GE         | N=V        | 有符号数大于或等于         |
>| 1011   | LT         | N≠V        | 有符号数小于               |
>| 1100   | GT         | Z=0,N=V    | 有符号数大于               |
>| 1101   | LE         | Z=1,N≠V    | 有符号数小于或等于         |
>| 1110   | AL         | 任何       | 无条件执行（指令默认条件） |
>| 1111   | NV         | 任何       | 从不执行（建议不要使用）   |

######  (4) 汇编语言基础

>- 样例工程创建
>
>~~~assembly
>;文件名 startup.s
>;启动文件
>STACK_TOP	EQU  0x20005000		; 宏定义主堆栈指针STACK_TOP
>			IMPORT	 mycode
>			AREA	RESET,	CODE	; 代码段的名字RESET(必须为RESET)
>			DCD	STACK_TOP	; 向量表第一项：堆栈指针值
>			DCD	start		; 向量表第二项：主程序入口地址
>			ENTRY			; 程序的入口
>start
>			MOV  R0, #0
>			MOV  R1, #10
>			LDR  R2, =mycode
>			BLX  R2			 ；转名称为mycode的用户程序
>deadloop
>			B	deadloop		; 在此死循环，空等待
>			END
>~~~
>
>```assembly
>;文件名 mycode.s
>	 		EXPORT		 mycode
>			AREA		ADDCODE, CODE	; 代码段的名字ADDCODE
>	
>mycode
>			ADD		R0,R0,R1
>			SUBS		R1,#1
>			BNE		mycode	
>			BX		R14
>			END 
>
>```

###### (5) 寻址方式

>- 概念
>
>寻址方式：确定指令中操作数来源的方法
>
>- 操作数可能来自指令代码、寄存器或存储单元
>
>- ARM Cortex-M 有以下种寻址方式
>
>1. 立即数寻址方式（Immediate Addressing Mode)  	操作数在指令代码中
>
>~~~assembly
>MOV	       R0, #0xFF
>~~~
>
>2. 寄存器寻址方式(Register Addressing Mode) 	操作数在寄存器中 
>
>~~~assembly
>MOV	       R1, R2
>SUB	       R0, R1, R2
>~~~
>> - 操作数的值在寄存器中，指令中的地址码字段指出的是寄存器编号，指令执行时直接取出寄存器值来操作
>> ~~~assembly
>> MOV  R1, R2	           ;将R2的值存入R1 
>> SUB  R0, R1, R2         ;将R1的值减去R2的值，结果保存到R0 
>> ~~~
>> - 寄存器移位寻址方式将寄存器内的数据经过移位处理后再参与运算。常用的移位方式有五种：
>> ~~~assembly
>> LSL：;逻辑左移（Logical Shift Left）
>> LSR：;逻辑右移（Logical Shift Right）
>> ASR：;算术右移（Arithmetic Shift Right）
>> ROR：;循环右移（ROtate Right）
>> RRX：;带扩展的循环右移（Rotate Right eXtended by 1 place）
>> ~~~
>> - 寄存器寻址方式允许对寄存器进行移位操作，这是ARM指令集特有的寻址方式。当第2个操作数是寄存器移位方式时，第2个寄存器操作数在与第1个操作数结合之前，选择进行移位操作。
>> ~~~assembly
>> MOV	R0,R2,LSL #3	    ;R2的值左移3位，结果放入R0，即R0=R2×8 
>> ANDS	R1,R1,R2,LSL R3     ;R2的值左移R3位，然后和R1相“与”操作，结果放入R1
>> ~~~
>> - 直接寻址是加载/存储指令访问存储空间时，在指令中直接给出操作数有效地址的一种寻址方式
>>   这个地址一般以标号的形式出现，但该标号必须在当前指令的±4 KB范围内。
>> ~~~assembly
>> ; ARM汇编代码示例 - 变量加载与数据段定义
>> 	LDR R0, myScore          		; 将变量myScore的值加载到寄存器R0中
>> 		AREA myData, DATA, READWRITE  	; 声明名为myData的数据段，可读写
>> 	myScore DCD 0X50         			; 定义变量myScore，赋初值为0X50
>> 	;该代码相当于把mycode地址里面存放的值 0x50 直接赋值给 R0
>> - 寄存器加偏移间接寻址方式
>>   - 寄存器间接寻址时，ARM指令的操作数存储在某个存储单元中，寄存器中存放的是操作数的地址
>>   - 这种寻址方式主要用于加载/存储单个存储器数据时
>>   ~~~assembly
>>   LDR  R1，[R2] 	； R1←[R2]
>>   ;将 R2 指向地址的数据赋值给R1
>> ~~~
>>   - 基址变址寻址是指操作数的有效地址是由寄存器的内容加上指令中给出的变址来确定的
>>   - 操作数所在存储单元的基地址由寄存器给出，这个寄存器就叫做基址寄存器
>>   - **变址既可以以立即数形式给出，也可以由寄存器来提供**
>>   ~~~assembly
>>   LDR  R3, [R4,#0X12]	;R3←[R4+0x12]，指令执行后R4的值不发生变化
>>   LDR R3, [R4,R5]		;R3←[R4+R5]
>>   ~~~
>
>>   - 在寄存器加偏移量寻址方式中，根据寄存器的内容是否改变、什么时候改变，又有零偏移、前索引偏移、后索引偏移和自动索引之分。
>
>>   ```assembly
>>   ;零偏移
>>   LDR     R2,  [R3]		;实际上就是寄存器间接寻址
>>   ;前索引偏移
>>   LDR    R2,  [R3, #0X4] 	; [(R3)+ #0X4]装入R2，R3值不变
>>   ;后索引偏移
>>   STR    R2, [R3], #0X4	; R2存入[R3]，R3+0X4送R3
>>   ;自动索引
>>   LDR     R2,  [R3,#0X4]!	; [(R3)+ #0X4]装入R2，R3+0X4送R3
>>  ```
>
> 
>
>3. 存储器寻址方式（ Mevmory Addressing Mode ）
>
>- 直接地址寻址方式(Direct Address Addressing Mode)	操作数在存储器中，地址指令直接给出
>
>~~~assembly
>LDR	       R0,Label
>~~~
>
>- 寄存器加偏移间接寻址方式(Register Plus Offset Indirect Addressing Mode)
>
> ~~~assembly
> LDR	       R0,[R1,#4]
> ~~~



###### (6) 数据形式

- 八位图数

  >所谓八位图数就是说，这个数是一个8位的二进制数（0~255），或者能用一个8位二进制数循环右移偶数位（0、2、4、6、…，28，30位）表示出来。由于ARM指令的32位编码中，留给操作数的只有12位，因此，不能表示出任意大小的数据。为了用12比特表示出32位立即数，约定将这12个比特分为两部分，其中8比特用来表示一个立即数，剩下的4比特共16种编码刚好用来表示对这个立即数循环右移的位数
  >
  >合法的八位图数如0XC000003F（可由0XFF循环右移2位得到）、0X3FC（可由0XFF循环右移30 位得到） ，非法的八位图数如0X8000007F（它不能由一个8位的常数循环右移偶数位得到）
  >
  >不符合八位图格式的立即数只能通过文字池来访问 

- 文字池

  >1. 默认文字池
  >
  >通过MOV指令不能把一个非8位位图的立即数送寄存器，但可以用LDR伪指令借助默认文字池的办法实现。
  >
  >注意：
  >
  >~~~assembly
  >	AREA	mydata,	DATA,	READONLY
  >x1	DCW		1,2,3,4,5,6,7,8,9
  >~~~
  >
  >
  >
  >~~~assembly
  >uLDR R0, =x1（伪指令）转换为：
  >LDR r0, [pc, #8] ; @0x0000002c;
  >uLDR R1, =0x12345678(伪指令）转换为：
  >LDR r1, [pc, #12] ; @0x00000030;
  >~~~
  >
  >- 文字池的使用限制是：LDR指令的寻址范围是前后4KB，不能使文字池与访问它的LDR指令之间的距离超过这个范围。如果用户程序比较大，则可能使整个程序段超过4KB的范围，这样汇编器在程序段的末尾开辟的缺省文字池与访问它的LDR指令之间的距离就有可能超出范围，LDR指令就不能正确加载数据了。
  >
  >  这时需要使用自定义文字池
  >
  >2. 自定义文字池
  >
  >~~~assembly
  >mycode
  >	ldr r1, =0x12345678
  >	ldr r2, =0x89654321
  >	sub r1, r2, r3
  >	LTORG					;在sub指令开辟自定义文字池
  >~~~
  >
  >

##### 2. 汇编语言程序设计基础

###### (1) 样例

- 代码样例

~~~assembly
;例 计算数据段中存放的五个数据的和，并存放到变量dst中。
			EXPORT mycode
			AREA	ADDCODE, CODE, READONL		
mycode		LDR	R0,=X1		
			MOV	R1, #5		
			MOV	R2, #0		
loop1		LDR	R3,[R0], #4		
			ADD	R2,R2,R3		
			SUBS	R1,R1,#1		
			BNE	loop1		
			LDR	R0,=X2		
			STR	R2,[R0]		
deadloop
			B	deadloop					
			AREA	MYDATA1, DATA, READONLY	
X1			DCD	1,2,3,4,5
			AREA	MYDATA2,DATA, READWRITE
X2			DCD	0
	
			END 
~~~

- 构成解释

>每个ARM汇编程序均由指令和汇编器伪指令构成，在例5-1中，黑色表示的内容均为指令，蓝色表示的内容均为汇编器伪指令。
>
>1.  **指令语句：**在汇编后能产生目标代码的语句，CPU可以执行并能完成一定的功能，例如MOV，ADD等；
>2. **汇编器伪指令：**在汇编后不产生目标代码的语句，仅在汇编过程中告诉汇编器如何汇编。汇编器伪指令的作用包括：定义数据、分配存储区、定义段、定义宏、定义子程序等。一旦汇编结束，它们的使命就完成了
>
>- 伪指令
>
>- 代码格式
>
>~~~assembly
>;语句的格式
>;ARM汇编语言程序的每行语句由1~4部分组成。
>
>[LABEL]	OPERATION      [OPERAND]	[;COMMENT]
>
>;标号域	操作助记符域      操作数域		注释域
>
>~~~
>
>- 所有标号必须在一行的顶格书写，其后不要添加“:”号；
>- 所有的指令均不能顶格写
>- 每一条指令的助记符可以全部用大写、或全部用小写，但不能在一条指令中大、小写混用
>- 注释使用分号“;”
>
>1. 标号
>
>   >在汇编语言程序设计中，可以使用各种标号表示指令或数据的地址，以增加程序的可读性。例如：
>   >
>  >```assembly
>   >Loop1 LDR R3, [R0], #4 
>   >… …
>   >BNE loop1 ;如果ZF不为1，则转向loop1处
>   > ```
>   >
>  > 以下为标号命名规则：
>   >
>   >1. 标号不应与系统保留字（指令或伪指令）同名
>  >
>   >   2. 标号在其作用范围内必须唯一。
>   >
>   >3. 标号区分大小写，同名的大、小写标号被视为两个不同的标号。
>
>2. 标号
>
>  >程序中的常量是指其值在程序的运行过程中不能被改变的量，变量是指其值在程序的运行过程中可以改变的量。ARM汇编程序支持逻辑量、数字和字符串。
>   >
>  >- 数字一般为32位的整数，无符号数取值范围为0～232-1，带符号数取值范围为-231～231-1
>  >- 逻辑量只有两种取值：真或假
>  >- 字符串用于在程序的运行中保存一个字符串，其长度不应超出字符串变量所能表示的范围
>   >
>
>3. 常量
>
>>程序中的常量是指其值在程序的运行过程中不能被改变的量，变量是指其值在程序的运行过程中可以改变的量。ARM汇编程序支持逻辑量、数字和字符串。
>>- 数字一般为32位的整数，无符号数取值范围为0～232-1，带符号数取值范围为-231～231-1。
>>- 逻辑量只有两种取值：真或假。
>>- 字符串用于在程序的运行中保存一个字符串，其长度不应超出字符串变量所能表示的范围。

###### (2) 伪代码

汇编器伪指令的作用包括：定义数据、分配存储区、定义段、定义宏、定义子程序等。一旦汇编结束，它们的使命就完成了

~~~assembly
;段定义相关伪指令
AREA
;语法格式： AREA	段名,   属性1, 属性2, ……
;程序5-1中使用如下语句定义段：
    	AREA	MAIN, CODE, R EADONLY	   ;定义代码段，名字为MAIN
END
;用于指示程序的结束，每一个汇编源程序都必须以END语句结束，以通知汇编器结束汇编。

;字节型变量定义伪指令DCB
;格式：
;标号	DCB	 表达式	[,	表达式]……   ；方括号内的内容为可选项；
;        DCB用于在内存中分配一片连续的字节单元，并用表达式进行初始化。每个表达式可以是数字或字符串，数字的范围在0～255内，也可以为算术表达式，例如：
str			DCB	“Hello World!” 
num_b		DCB	2+3, 3*5

;DCW
;语法格式：
;标号   DCW  表达式  [,	表达式]……
;    DCW用于在内存中分配一片连续的半字单元，并用指定的表达式进行初始化。这些分配的内容是半字对齐的。其中表达式可以为程序标号或者数字表达式。例如：
num_w	DCW		0x1234，0x5678

;DCD
;语法格式：
;标号	DCD	  表达式	[,	表达式]……   
    
;    DCD用于在内存中分配一片连续的字单元，并用指定的表达式进行初始化。这些分配的内容是字对齐的。其中表达式可以为程序标号或者数字表达式。例如：
num_d		DCD		-5，0x90abcdef


;SPACE
;语法格式：
;标号	 SPACE	表达式 
   SPACE用于分配一片连续的存储区域并初始化为0。其中，表达式为要分配的字节数。例如：
data	   SPACE	  1024     	   ;分配1024个字节空间并初始化为0

;LTORG
;LTORG 用于声明一个文字池，用来存放常量，特别是不符合8位位图数据标准的常数。

;符号定义伪指令
;EQU
;         EQU用于将表达式的值赋予一个名字。在后面的程序中可以用这个名字来代替该表达式，类似于C语言中的宏定义#define。例如：
TIMES1		EQU		0x5
TIMES2		EQU		30*50
;注意：在同一个程序中，EQU不能对一个名字赋值两次。


;NOP空操作
nop
;表示不执行任何指令，类似于pass
~~~

###### (3) 指令讲解

- 数据传送类指令

  >把一个立即数加载到寄存器
  >
  >- 立即数能表示成八位位图，直接用MOV指令送
  >
  >~~~assembly
  >MOV	R0,#10
  >MVN	R1,#0
  >~~~
  >
  >- 若立即数不能表示成八位位图，则需要用LDR伪指令实现把立即数送寄存器
  >
  >~~~assembly
  >MOV   R1,#0X2F3F30
  >;立即数#0X2F3F30表示不成把位位图，汇编不通过 
  >;使用伪指令：
  >LDR	R1,=0X2F3F30 ；LDR  R1,[PC,#0]
  >;通过默认文字池把立即数0X2F3F30送寄存器R1
  >;伪指令LDR  R1,=0X2F3F30经汇编器汇编后变为指令
  >;0x0000001C 4900    LDR      r1,[pc,#0]  ; @0x00000020 
  >~~~
  >
  >- LDR/STR单操作数传送
  >
  >用于访问存储器的基础指令是“加载（Load）”和“存储（Store）”。加载指令LDR 把存储器中的内容加载到寄存器中，存储指令STR 则把寄存器的内容存储至存储器中，传送过程中数据类型也可以变通，最常使用的格式有：
  >
  >| **指令** |            **格式**            | **数据宽度** |    **操作方向**     |                         **功能描述**                         |
  >| :------: | :----------------------------: | :----------: | :-----------------: | :----------------------------------------------------------: |
  >| **LDRB** |    `LDRB Rd, [Rn, #offset]`    | 8位（字节）  | 加载（内存→寄存器） |      从地址 `Rn+offset` 读取一个字节，零扩展后存入 `Rd`      |
  >| **LDRH** |    `LDRH Rd, [Rn, #offset]`    | 16位（半字） |        加载         |      从地址 `Rn+offset` 读取一个半字，零扩展后存入 `Rd`      |
  >| **LDR**  |    `LDR Rd, [Rn, #offset]`     |  32位（字）  |        加载         |        从地址 `Rn+offset` 读取一个字（32位）存入 `Rd`        |
  >| **LDRD** | `LDRD Rd1, Rd2, [Rn, #offset]` | 64位（双字） |        加载         | 从地址 `Rn+offset` 读取双字（64位），低32位存 `Rd1`，高32位存 `Rd2` |
  >| **STRB** |    `STRB Rd, [Rn, #offset]`    | 8位（字节）  | 存储（寄存器→内存） |            将 `Rd` 的低字节存储到地址 `Rn+offset`            |
  >| **STRH** |    `STRH Rd, [Rn, #offset]`    | 16位（半字） |        存储         |            将 `Rd` 的低半字存储到地址 `Rn+offset`            |
  >| **STR**  |    `STR Rd, [Rn, #offset]`     |  32位（字）  |        存储         |         将 `Rd` 的低字（32位）存储到地址 `Rn+offset`         |
  >| **STRD** | `STRD Rd1, Rd2, [Rn, #offset]` | 64位（双字） |        存储         | 将 `Rd1`（低32位）和 `Rd2`（高32位）组合为双字，存储到 `Rn+offset` |
  >
  >~~~assembly
  >;从寻址方式的地址计算方法分，加载/存储指令有以下格式： 
  >;零偏移		如：
  >LDR  Rd,[Rn] 
  >;前索引偏移		如：
  >LDR  Rd,[Rn,#0x04]
  >LDR  Rd,[Rn,#0x04]!
  >;后索引偏移		如：
  >LDR  Rd,[Rn],#0x04
  >;注意
  >;（1）大多数情况下，必须保证字数据操作的地址是32位对齐的。
  >;（2）注意！的使用
  >~~~
  >
  >>[!NOTE]
  >>- 在READONLY只读存储器使用LDR/STR指令
  >>片内ROM被设置在地址低位0x00000000开始的若存储单元
  >>该存储区可以进行初始化，其中的数据可以读出来，但不能写进去。
  >>- 在READWRITE随机读写存储器RAM中使用LDR/STR指令
  >>片内RAM被设置在地址低位0x20000000开始的若存储单元
  >>该存储区可以读出来，也写进去。但不能进行初始化
  >
  >- LDR指令把一个单元中的字节数据或两个单元中的半字数据装入32位的寄存器时，需要注意是无符号数还是有符号数
  >
  >~~~assembly
  >;若是无符号数，使用：
  >     LDRB   R1，[R0]
  >;若是有符号数，使用：
  >     LDRSB   R1，[R0]
  >~~~
  >
  >- LDM和STM  多寄存器加载存储指令
  >
  >|         **指令格式**          | **操作模式** | **位宽** | **地址变化规则** |           **功能描述**           | **堆栈操作等效指令** |
  >| :---------------------------: | :----------: | :------: | :--------------: | :------------------------------: | :------------------: |
  >|  **LDMIA Rd!, {寄存器列表}**  |     加载     |   16位   | 每次读取后地址+4 | 从Rd指向地址连续加载多个寄存器值 | 无（非标准堆栈操作） |
  >|  **STMIA Rd!, {寄存器列表}**  |     存储     |   16位   | 每次存储后地址+4 | 向Rd指向地址连续存储多个寄存器值 | 无（非标准堆栈操作） |
  >| **LDMIA.W Rd!, {寄存器列表}** |     加载     |   32位   | 每次读取后地址+4 |        增强版32位宽度加载        |   POP（当Rd=SP时）   |
  >| **LDMDB.W Rd!, {寄存器列表}** |     加载     |   32位   | 每次读取前地址-4 |          先减地址再加载          |  无（反向堆栈操作）  |
  >| **STMIA.W Rd!, {寄存器列表}** |     存储     |   32位   | 每次存储后地址+4 |        增强版32位宽度存储        | 无（非标准堆栈操作） |
  >| **STMDB.W Rd!, {寄存器列表}** |     存储     |   32位   | 每次存储前地址-4 |          先减地址再存储          |  PUSH（当Rd=SP时）   |
  >
  >- 发现以下现象：
  >
  >LDM指令中，从对应存储区中把存储区内容装入寄存器时，不论指针是增加还是减少，结果都是高地址对应元素送编号大的寄存器
  >
  >STM指令中，编号大的寄存器内容送地址大的存储器单元。
  >
  >传送模式由以前的4种变为2种（IA，DB）---更简洁实用了！
  >
  >- LDR伪指令的三种用法
  >
  >  1. 把立即数送寄存器（通过文字池）
  >  2. 把变量地址送寄存器
  >  3. 把程序转移地址送寄存器，A0置1
  >
  >  ADR伪指令只能把程序转移地址送寄存器，且A0不置1（注意指令中标号前不用“=”）
  >

- 数据处理类指令

  >- 逻辑运算以及移位指令
  >
  >~~~assembly
  >AND ;逻辑与指令
  >ORR ;逻辑与指令
  >EOR ;逻辑异或指令
  >NEG ;求补指令
  >LSL ;逻辑左移（Logical Shift Left）
  >LSR ;逻辑右移（Logical Shift Right）
  >ASR ;算术右移（Arithmetic Shift Right）
  >ROR ;循环右移（ROtate Right）
  >RRX ;带扩展的循环右移（Rotate Right eXtended by 1 place）
  >BFC ;位段清零指令
  >BFC ;位段清零指令
  >BIC ;取反与指令
  >ORN ;取反或指令
  >RBIT ;位置换指令
  >REV ;字节交换指令
  >REV16 ;半字交换指令
  >REVSH ;低半字字节交换指令
  >~~~
  >
  >
  >
  >- 常规加法指令
  >
  >~~~assembly
  >ADD  	R0, #0x12  	;R0=R0+12，所有立即数寻址的指令都是
  >		;32位，不影响标志位
  >ADD 	R0, R1  	; R0=R0+R1,16位指令,不影响标志位
  >ADD 	R0, R0, R1 	; R0=R0+R1, 16位指令,不影响标志位
  >ADD.W 	R0, R0, R1 	; R0=R0+R1, 32位指令,不影响标志位	
  >ADD.N   	R0, R0, R1 	; R0=R0+R1, 16位指令,不影响标志位	
  >ADDS.N   	R0, R0, R1 	; R0=R0+R1, 16位指令,影响标志位，
  >		;“.N”没有必要
  >~~~
  >
  >说明
  >
  >1. 有立即数的指令都会自动汇编成32位指令；
  >
  >2. 默认情况下，汇编器会设法把指令汇编成较短的指令，即若能用16位来表示，就不会汇编成32位指令。如：
  >
  >  ADD R0, R1       ; 自动汇编成16位指令
  >
  >  ADD R0, R0, R1   ; 自动汇编成16位指令
  >
  >  ADD.W  R0，R1 ;汇编成32位指令。一般情况下“.W”和“.N”都没有意义
  >
  >3. 不论是16位还是32位指令，若不用“S”后缀，都不会自动更新APSR(Application Program Status Register) 中的标志位。若想根据当前指令的运行结果决定程序流向，所有指令都必须显式的使用“S”来把当前指令运行结果体现在APSR中。
  >
  >- 带进位加法指令
  >
  >~~~assembly
  >ADD 	R0, R2	 	; R0 = R0+R2, 16位指令, 不影响标志位
  >ADCS 	R1, R1, R3	; R1 = R1+R3+CF, 16位指令, 影响标志位
  >ADCS	R0,R1		; R0 = R0+R1+CF, 16位指令, 影响标志位
  >ADCS 	R0, R0,R1	; R0 = R0+R1+CF, 16位指令, 影响标志位
  >ADCS.W 	R0, R0,R1	; R0 = R0+R1+CF, 32位指令, 影响标志位
  >ADCS.N 	R0, R0,R1	; R0 = R0+R1+CF, 16位指令, 影响标志位
  >~~~
  >
  >- 常规减法指令
  >
  >~~~assembly
  >SUB	R0,#1 		; R0 = R0-1, 32位指令, 不影响标志位
  >SUB	R0,R0,#1 	; R0 = R0-1, 32位指令, 不影响标志位
  >SUB	R0,R9,#1 	; R0 = R9-1, 32位指令, 不影响标志位
  >SUB	R0,R10 		; R0 = R0-R10, 32位指令, 不影响标志位
  >SUB	R0,R0,R10 	; R0 = R0-R10, 32位指令, 不影响标志位
  >SUB	R0,R10,R1 	; R0 = R10-R1, 32位指令, 不影响标志位
  >~~~
  >
  >- 带借位减法指令
  >
  >~~~assembly
  >SUBS	R0,#1; R0 = R0-1, 16位指令, 影响标志位
  >SBCS	R0,R0,#1; R0 = R0-1-CF, 32位指令, 影响标志位
  >SBCS	R0,R9,#1; R0 = R9-1,-CF 32位指令, 影响标志位
  >	;说明：有立即数寻址的指令比较特殊，有些会被汇编成16位指令，有些被汇编成32位指令。读者在学习时没有比较纠结汇编器会把指令汇编成16位还是32位指令。但大家只要知道，汇编器会尽量使用尽可能少的字节来表示指令，从而优化代码，提高程序执行效率。
  >SBCS	R0,R7; R0 = R0-R10, 16位指令, 影响标志位
  >SBCS	R0,R0,R10; R0 = R0-R10, 32位指令, 影响标志位
  >SBCS	R0,R10,R1; R0 = R10-R1, 32位指令, 影响标志位
  >~~~
  >
  >- 反向减法指令  解决被减数为立即数的情形需求
  >
  >~~~assembly
  >;type 1
  >	RSB.W 	Rd, Rn, #imm12 	; Rd = imm12-Rn
  >;tpye 2
  >	RSB.W 	Rd, Rn, Rm 	; Rd = Rm-Rn
  >	RSB	R0,#5
  >	RSB.W	R0,#5
  >	RSB	R0,R0,#5
  >	RSB.W	R0,R0,#5  ;四种写法对应的机器指令相同
  >
  >	RSB	R1,R2
  >	RSB	R1,R1,R2
  >	RSB.W	R1,R1,R2 ; 三种写法对应的机器指令相同
  >   RSB	R0,R3,R4
  >~~~
  >
  >- 乘法指令
  >
  >~~~assembly
  >;type 1
  >MUL 	Rd, Rm 		; Rd *= Rm
  >MUL.W 	Rd, Rn, Rm 	; Rd = Rn*Rm
  >;type 2
  >	MUL	R0,R1
  >	MUL	R0,R0,R1 ;这两条指令机器码相同
  >
  >	MUL	R0,R1,R2
  >	MUL.W	R0,R1,R2 ;这两条指令机器码相同
  >~~~
  >
  >- 乘加与乘减指令
  >
  >~~~assembly
  >MLA   Rd, Rm, Rn, Ra	 ; Rd = Ra+Rm*Rn
  >MLS 	  Rd, Rm, Rn, Ra	 ; Rd = Ra-Rm*Rn
  >;example
  >	AREA	ADDCODE, CODE, READONLY		mycode
  >	LDR	R5,=X1
  >	LDM	R5,{R0-R9}
  >	MLA	R0,R1,R2,R3
  >	MLS	R0,R1,R2,R9	
  >deadloop
  >	B	deadloop					
  >	AREA	MYDATA,	DATA, READONLY		
  >X1	DCD	1,2,3,4,5,6,7,8,9,10
  >~~~
  >
  >- 无符号的64位乘法
  >
  >~~~assembly
  >UMULL   RL, RH, Rm, Rn	 ;[RH:RL]= Rm*Rn
  >UMLAL   RL, RH, Rm, Rn 	;[RH:RL]+= Rm*Rn
  >~~~
  >
  >- 带符号的64位乘法
  >
  >~~~assembly
  >SMULL   RL, RH, Rm, Rn 	;[RH:RL]= Rm*Rn
  >SMLAL   RL, RH, Rm, Rn 	;[RH:RL]+= Rm*Rn
  >~~~
  >
  >- 除法指令举例
  >
  >~~~assembly
  >;UDIV Rd, Rn, Rm ; Rd = Rn/Rm （无符号除法）
  >;SDIV Rd, Rn, Rm ; Rd = Rn/Rm （带符号除法）
  >;example
  >	EXPORT mycode
  >	AREA	ADDCODE, CODE, READONLY	
  >Mycode
  >	LDR		R5,=X1
  >	LDM		R5,{R0-R10}
  >
  >	UDIV	r0,r10,r1
  >	SDIV	R0,R9,R2	
  >Deadloop
  >	B		deadloop				AREA	MYDATA,	DATA, READONLY
  >X1	DCD	1,2,3,4,5,6,7,8,9,-10,11
  >	END
  >~~~

- 控制转移类指令

  >- 最基本的**无条件转移指令**有两条：
  >
  >~~~assembly
  >B 	Label		;转移到Label 处对应的地址
  >BX 	reg 		;转移到由寄存器reg 给出的地址
  >~~~
  >
  >  在BX 中，reg 的最低位指示出在转移后，将进入的状态是ARM(LSB=0)还是Thumb(LSB=1)。既然CM3 只在Thumb 中运行，就必须保证reg 的LSB=1，否则fault 伺候
  >
  >- 子程序调用指令
  >
  >~~~assembly
  >BL 	Label 	;转移到Label 处对应的地址
  >                     	;并且把转移前的下条指令地址保存到LR
  >BLX reg 	;转移到由寄存器reg 给出的地址
  >		        	;并且把转移前的下条指令地址保存到LR
  >~~~
  >
  >  使用BLX 要小心，因为它还带有改变状态的功能。因此reg 的LSB 必须是1，以确保不会试图进入ARM 状态。如果忘记置位LSB，则fault 伺候
  >
  >- 在应用程序状态寄存器中有5 个标志位，但只有4 个被条件转移指令参考。绝大多数ARM 的条件转移指令根据它们来决定是否转移
  >
  >|      标志位      | PSR位序号 |                           功能描述                           |
  >| :--------------: | :-------: | :----------------------------------------------------------: |
  >| **N** (Negative) |    31     | 负数标志（上一次操作结果为负数）。N=操作结果的最高有效位(MSB) |
  >|   **Z** (Zero)   |    30     | 零标志（上次操作结果为0）。当数据操作指令结果为0，或比较/测试结果为0时置位 |
  >|  **C** (Carry)   |    29     | 进位/借位标志（上次操作导致进位或借位）。用于无符号数据处理： • 加法进位时置位 • 减法借位时置位 • 同时作为移位指令的中介（详见v7M参考手册） |
  >| **V** (oVerflow) |    28     | 溢出标志（上次操作导致数据溢出）。用于带符号数据处理： • 两个正数相加结果为负时置位 • 两个负数相加结果为正时置位 |







###### (4) 几种程序结构

- 顺序结构 

  ~~~assembly
  ;eg. 已知32位字变量X=1,Y=2,要求实现Z=X+Y，结果存放在Z中
          EXPORT 	mycode
  		AREA	ADDCODE, CODE, READONLY			
  mycode
  	        	LDR	R0,=X
  		LDR	R1,[r0]
  		LDR	R0,=Y
  		LDR	R2,[r0]
  			
  		ADD	R1,R2
  			
  		LDR	R0,=Z
  		STR	R1,[R0]
  deadloop
  		B	deadloop					
  			
  		AREA	MYDATA1,DATA, READONLY		
  X		DCD	1
  Y		DCD	2
  
  		AREA	MYDATA2,DATA, READWRITE
  Z		DCD	0
  		END
  
  ~~~

- 分支结构

  ~~~assembly
  ;code 1
  ;已知32位有符号数X存放在存储器的地址0x90010中，要求实现(注意系统rom，ram地址空间的分配)
  ;     Y=X   （X〉=0）或 Y=-X   （X<0）
  ;  并将结果Y存放在0X90020中。
  			EXPORT mycode
  			AREA	ADDCODE, CODE, READONLY			
  mycode
  	        		LDR	R1,=0x20000010
  			MOV	R2,# -1
              		STR  	R2,[R1]
  			LDR	R2,[R1]
  			MOV	R0,#0
  			CMP	R2,R0
  			SUBLT	R2,R0,R2
  	        		LDR	R1,=0X20000020
  			STR	R2,[R1]
  deadloop
  			B		deadloop					
  			END
  ;code 2
  ;已知32位有符号数X，要求实现：Y=X（X〉0）或 Y=0 （X=0）或Y=-X（X<0）,并将结果存放到Y中
  
  			EXPORT mycode
  			AREA	ADDCODE, CODE, READONLY			
  mycode
  			LDR		R1,=X
  			LDR		R2,[R1]
  			MOV		R0,#0
  			CMP		R2,R0
  			SUBLT		R2,R0,R2
              		LDR		R1,=Y
  			STR		R2,[R1]
  deadloop
  			B		deadloop					
  			AREA 	FZDATA1,DATA,READONLY
  X			DCD	-1
  			AREA 	FZDATA2,DATA,READWRITE
  Y			DCD	0
  			END
  ~~~

- 循环结构

  - 格式

    ~~~assembly
    ;计数控制：当循环次数已知时，通常使用计数控制法。
    			MOV	Rn，#N	;循环初值部分
    			…
    	LOOPA	…			;循环体
    			…
    			…
    			SUBS	Rn，Rn，#1	;修改部分
    			BGT	LOOPA	;控制部分
    ;直到Rn=0时，循环结束。
    ;结束条件已知：每循环一次计数其加一，直到满足结束条件时结束。
    			MOV	Rn，#0	;循环初值部分
    			…
    	LOOPA	…			;循环体
    			…
    			…
    			ADDS	Rn，Rn，#1	;修改部分
    			CMP	Rn，#N
    			BNE	LOOPA	;控制部分
    ;直到Rn=N时，循环结束。
    ;eg.
    ;例如：编制程序使S=1+2*3+3*4+4*5+…+N(N+1)，直到N等于10为止。
    			EXPORT mycode
    			AREA	ADDCODE, CODE, READONLY			
    mycode
    			MOV		R0,#0	
    			MOV		R1,#1
    			LDR		R4,=X
    			LDR		R3,[R4]
    REPEAT		ADD		R0,R1	
    			ADD		R1,#1
    			SUBS	R3,#1
    			BNE		REPEAT
    			LDR		R4,=Y
    			STR		R0,[R4]
    deadloop
    			B		deadloop					
    			AREA 	FZDATA1,DATA,READONLY
    X			DCD		10
    			AREA 	FZDATA2,DATA,READWRITE
    Y			DCD		0
    			END
    ~~~

  - 多重循环

    ​    多重循环即循环体内嵌套循环。设计时可以从外层循环到内层循环，一层一层的进行。通常在设计外层时，仅把内层看成一个处理粗框，然后再将该粗框细化成置初值、工作、修改和控制等四个部分。

    ~~~assembly
    ;例：在以BUF为首地址的字存储区中存放有10个无符号数
    ;;0x0FF,0x00,0x40,0x10,0x90,0x20,0x80,0x30,0x50,0x70
    ;现需将他们按从小到大的顺序排列在BUF中，使编写其程序。
    ;分析：“冒泡排序法”。
    ;	寄存器分配如下：
    ;		R0：指示缓冲区初始地址
    ;		R1：外循环计数器
    ;		R2：内循环计数器
    ;		R3：外循环地址指针
    ;		R4：内循环地址指针
    ;		R5：内循环下一个数地址指针
    ;		R6：存放内循环一轮比较的最小值
    ;R7：存放内循环取出的下一个比较值
    ;code
    N	EQU	10
    		AREA	BlockData1,DATA, READONLY
    BUF1	DCD   	10,9,8,7,6,5,4,3,2,1
    		AREA	BlockData2,DATA, READWRITE
    BUF2	SPACE 	80
    		END
    			EXPORT mycode
    			AREA	ADDCODE, CODE, READONLY			
    Mycode		LDR	R0, =BUF1
    			LDMIA    	R0!,{R1-R10}
    			LDR	R0, =BUF2
    			STMIA    	R0!,{R1-R10}
    				
    			LDR	R0, =BUF2		;指向数组的首地址
    			MOV	R1, #0		;外循环计数器
    			MOV	R2, #0		;内循环计数器
    LOOPI	 		ADD	R3, R0, R1, LSL #2	;外循环首地址放入R3
    			MOV	R4, R3		;内循环首地址放入R4
    			ADD	R2, R1, #1		;内循环计数器初值
    			MOV	R5, R4		;内循环下一地址初值
    			LDR	R6, [R4]		;取内循环第一个值R4
    LOOPJ	 		ADD	R5, R5,#4		;内循环下一地址值
    			LDR	R7, [R5]		;取出下一地址值R7
    			CMP	R6, R7		;比较
    			BLT	NEXT		;小则取下一个
    			;SWP	R7, R6,[R5]		;大则交换，最小值R6---用以下两条指令替换
    			ldr	r7,[r5]
    			str	r6,[r5]
    			MOV	R6,R7		;R6放当前找到的最小数
    NEXT	 		ADD	R2,R2,#1		;内循环计数器
    			CMP	R2, #N		;循环终止条件
    			BLT	LOOPJ		;小于N则继续内循环，实现比较一轮
    			;SWP	R7, R6, [R3]	;否则，内循环一轮结束，将最小数存入外循环的首地址处---用以下两条指令替换
    			ldr	r7,[r3]
    			str	r6,[r3]
    			ADD	R1, R1, #1		;外循环计数
    			CMP	R1, #N-1		;外循环终止条件
    			BLT	LOOPI		;小于N-1继续执行外循环
    
    ~~~

- 子程序

  ~~~assembly
  ;保护现场、参数传递、恢复现场、子程序返回
  			AREA	Exam，CODE，READONLY
  			ENTRY
  START		LDR	R0，=0x3FF5000
  			LDR	R1，=0x3FF5008
  			STMFD  R13 !，{ R0-R2 , R14 }
  			BL	Print_Text
  			…
  Print_Text	…
  			…
  			LDMFD  R13 !，{ R0-R2 , PC }
  			MOV	PC，R14
  			END
  ;eg
  ;编写子程序，实现将字符串Str1(其地址放R0，以0结束)拷贝到字符串Str2（其地址放R1）中
  	EXPORT mycode
  	AREA	ADDCODE, CODE, READONLY			
  	
  mycode
  	LDR	R0, =src	;R0指向src的起始地址
  	LDR	R1, =dst	;R1指向dst的起始地址
  	BL	strcpy	;小于N-1继续执行外循环
  
  deadloop
  	B	deadloop					
  
  			
  strcpy
  	LDRB	R2, [R0], #1	;将R0指向的字节存入R2中，R0自加1，指向下一个字节
  	STRB	R2,[R1], #1	;将R2内容存入R1指向的字节单元中;R1自加1，指向下一个字节
  	CMP	R2,#0	;检查R2是否为0
  	BNE	strcpy	;没有遇到结束符0时，继续拷贝下一个字节
  	MOV	PC,LR	;子程序返回
  
  	AREA	NUM1,	DATA,	READONLY		
  Src	DCB	"Hello world! I am an ARM program!", 0 
  	AREA	NUM2,	DATA,	READWRITE
  dst	SPACE	100 	
  	END
  ~~~



##### 3. 汇编和c语言联动

###### (1) 概览

在实际编程时，程序的初始化部分用汇编语言完成，用C或C++完成主要的编程任务。为了保证程序调用时参数传递的正确性，汇编语言程序的设计要遵守ATPCS（ARM-Thumb Proceduce Call Standard）---过程调用标准，这些基本规则包括子程序调用过程中寄存器的使用规则、堆栈的使用规则以及参数传递规则等。

​    尽管在使用了C后，大大加速了开发，但是底层的系统控制往往还需要汇编代码。很多编译器都允许你直接在C代码中插汇编，称为“内联汇编”；以往，使用**内联汇编**的作法比较多，但是在ARM编译器中，不支持对Thumb‐2指令的内联汇编。取而代之的，是从RealView C编译器的3.0版开始，新增了所谓“嵌入式汇编”的功能，它支持Thumb‐2指令。它让你可以在C程序中插入使用汇编语言编写的函数。

​    在CM3 中，嵌入式汇编还是比较需要的，因为常常会有访问特殊功能寄存器的时候。比如，在设置堆栈时，就要使用MRS/MSR 指令。对于其它不能由编译器产生的指令，比如WFI/WFE、互斥访问、存储器隔离等指令，也必须用汇编显式给出。



ATPCS：

1. 寄存器的使用规则

   >- **子程序间通过寄存器R0-R3来传递参数，记作A0-A3**。被调用的子程序在返回前无需恢复寄存器R0-R3的内容—也即这些寄存器的值是由调用者保存的。
   >
   >- 子程序使用R4-R11寄存器来保存局部变量，记作V1-V8。如果被调用的子程序要用到R4-R11，在进入时要保存这些寄存器的值—压栈，使用完后在返回前必须恢复这些寄存器的值—出栈，也即这些寄存器的值是由被调用者保存的。
   >
   >- 寄存器R12用作子程序间临时寄存器，记作IP。
   >
   >- 寄存器R13用作数据栈指针，记作SP，不能用作他用。在子程序进入和退出时SP的值必须相等。
   >
   >- 寄存器R14称为链接寄存器，记作LR。它用作保存子程序的返回地址。
   >
   >- 寄存器R15是程序计数器，记作PC。不能用作其他用途。
   >
   >  | 寄存器  | 别名 | 特殊名称 |           使用规则           |
   >  | :-----: | :--: | :------: | :--------------------------: |
   >  | **R0**  |  A1  |    -     |    参数/结果/临时寄存器1     |
   >  | **R1**  |  A2  |    -     |    参数/结果/临时寄存器2     |
   >  | **R2**  |  A3  |    -     |    参数/结果/临时寄存器3     |
   >  | **R3**  |  A4  |    -     |    参数/结果/临时寄存器4     |
   >  | **R4**  |  V1  |    -     |       局部变量寄存器1        |
   >  | **R5**  |  V2  |    -     |       局部变量寄存器2        |
   >  | **R6**  |  V3  |    -     |       局部变量寄存器3        |
   >  | **R7**  |  V4  |    -     |       局部变量寄存器4        |
   >  | **R8**  |  V5  |    -     |       局部变量寄存器5        |
   >  | **R9**  |  V6  |    -     |       局部变量寄存器6        |
   >  | **R10** |  V7  |    SL    | 局部变量寄存器7/堆栈限制指针 |
   >  | **R11** |  V8  |    FP    |            帧指针            |
   >  | **R12** |  -   |    IP    |  子程序内部调用的临时寄存器  |
   >  | **R13** |  -   |    SP    |           堆栈指针           |
   >  | **R14** |  -   |    LR    |          链接寄存器          |
   >  | **R15** |  -   |    PC    |          程序计数器          |

2. 堆栈的使用规则

   >- 只要有一个函数被调用，在堆栈中就产生一个新的活动帧，其中包含回溯记录、局部变量等。
   >
   >- 堆栈可分为满栈和空栈，当栈指针指向最后一个入栈的数据元素时，称为满栈。否则称为空栈。
   >
   >- 根据栈的增长方向不同可以分为递增栈和递减栈。
   >
   >   满递减栈（Full Descending）
   >
   >   空递减栈（Empty Descending ）
   >
   >   满递增栈（Full Ascending ）
   >
   >   空递增栈（Empty Ascending ）
   >
   >- ATPCS规定堆栈为FD类型，并且对堆栈的操作是4字节对齐的。
   >
   >

3. 参数传递使用规则

   >- 对于参数可变的子程序，当参数不超过4个时，可以使用寄存器R0~R3来传递；当参数超过4个时，将剩余的参数用堆栈来传递，入栈的顺序与参数的顺序相反，最后一个先入栈。
   >
   > 结果为一个32位整数时，通过R0返回。
   >
   > 结果为一个64位整数时，通过R0、R1返回，依此类推。
   >
   > 对于位数更多的结果，需要通过内存来传递。

###### (2) c语言调汇编

- 在主调程序C中用EXTERN关键字声明被调用的外部汇编过程
- 在被调的汇编过程中使用EXPORT作声明本过程可以被外部调用

~~~assembly
;.s文件
 		AREA  ARM_add, CODE, READONLY
		EXPORT add_s 
add_s 
		ADD r0,r0,r1
    	MOV pc,lr
    	end
~~~

~~~c
extern int add_s (int x,int y); 
int main(){
	int a=1,b=2,c;
	printf("\na=%d",a);
	printf("\nb=%d",b);
	c=add_s(a,b); 
	printf("\na+b=%d",c);
	return 0;
}
~~~

###### (3) c语言嵌入汇编

- 内嵌汇编指令中最好不使用物理寄存器名称，以免编译时出错

- 格式：__asm {}—注意asm前是两个下划线

~~~c
int badf(int x);
int max(int a,int b,int c);

 int main(void)
{        int 	ch;
          int	x;
          ch=badf(10);
          printf("ch=%d",ch);
          x = max(4,1,20);
          printf("\nmax=%d",x);
          return 0;
}
int badf(int x)
{                      
    __asm
	{add x,x,1}
	return(x);}
int max(int a,int b,int c)
{	int maxtem;
	__asm
	{    mov 	maxtem,a
	     cmp	 maxtem ,b
	     bhi	loop1
	     mov	maxtem, b
        loop1:
        	     cmp	maxtem,c
	     bhi	 loop2
	     mov  	maxtem,c
        loop2:	     mov	a,maxtem 		
	}
	return(a); 
}

~~~



###### (4) 汇编调用c语言

- 在汇编工程的主调汇编程序中，使用IMPORT声明要调用的C函数；C函数中不需要做任何声明
- 注意参数传递遵循相关标准：R0,R1,R2,R3作为C函数砂的前4个参数，若还有更多参数，需通过堆栈传递

>​    在这些情况下，必须知晓参数是如何传递的，以及值是如何返回的，才能在主调函数与子程序之间协同工作。这些交互的机制在ARM中有明确的规定，由文档《ARM ArchitectureProcedure Call Standard(AAPCS, Ref5)》给出。
>
>​    不过，在大多数场合下的情况都比较简单：当主调函数需要传递参数（实参）时，它们使用R0‐R3。其中R0传递第一个，R1传递第2个……在返回时，把返回值写到R0中。在子程序中，可以随心所欲地使用R0‐R3，以及R12（回顾第9章，想想为什么会PUSH它们）。但若使用R4‐R11，则必须在使用之前先PUSH它们，使用后POP回来。

~~~assembly
STACK_TOP	EQU	0x20005000		
	IMPORT 	fun1
	AREA	RESET,	CODE		    	DCD	STACK_TOP			      	DCD	start			ENTRY				
start
	mov	r0,5
	LDR  	R10, = fun1
	BLX   	R10
deadloop
	B	deadloop		
	END
~~~

~~~C
int fun1(int n)
{
	
	int i,sum=0;
	for(i=0;i<=n;i++)
	{
	sum=sum+i;
	}
	return sum;
}
~~~

###### (5) 汇编访问c中全局变量

- 在C工程的主调汇编程序中，定义全局变量；用EXTERN声明一个汇编过程
- 在汇编过程中使用IMPORT声明要使用的C中的外部变量；用EXPORT声明汇编中定义的过程可以被外部访问

~~~c
extern int add_v(int addnum);  
int globvar=3;     
int main()
{  	int     changedglobvar;
	int     addn=255;
	printf("globvar=%d",globvar );
	changedglobvar = add_v(addn);
	printf("\nchangedglobvar=%d",changedglobvar );
	return(0);
}

~~~

~~~assembly
AREA EX4_57,CODE,READONLY
        EXPORT add_v
        IMPORT globvar           
add_v	
        mov	r10,r0		
       LDR 	R1,=globvar          
        LDR 	R0,[R1]              
        ADD 	R0,R0,R10             
        STR 	R0,[R1]             
        MOV 	PC,LR
        END

~~~

###### (6)典型开发流程

- 在开发基于CM3的应用程序时，常常有多种源程序和库，有些是自己写的，有些是别人已经写好的（尤其是底层的软件）。上述这些开发工具，在代码生成的流程都差不离。对于最基本的应用，也至少需要C编译器，连接器以及二进制文件处理工具。如果使用的是ARM的工具，如RVDS或RealView 编译器工具（RVCT），则它们的流程如下图所示。**其中的“分散加载脚本”是可选的，但是当存储器映射变得比较复杂时，则需要它。**

![文件关系](.\img\文件关系.png)



 本章为提供了若干汇编写的例子，在实际应用中，这些程序都会用C写。**但是以汇编的方式呈现，有助于让读者更深更好地理解**CM3的工作内幕，以便在以后用C开发时心里更有底。这里给的程序都用ARM的汇编器(armasm)来汇编，其它工具可能对语法格式有些不同的要求。

​    而且实际上，开发工具几乎都会把启动工作为你做好，让你根本不用去想还有启动代码的事（**不过，这也妨碍了我们学习得更深入**）



### 四、stm32编程

#### 1. GPIO

#### 2. 中断

##### (1) 概述

中断是一种常见的、外设主动请求与CPU进行通信的方式，CPU不需要浪费时间等待或查询外设状态，大大提高了工作效率，且能快速响应、及时处理异步事件

#####  (2) 中断处理的一般过程

1. 中断请求

2. 中断响应：应答；获取中断类型号，查找中断服务程序入口地址

3. 断点保护：中断返回地址入栈（硬件自动完成）

4. 中断处理

5. 中断返回







