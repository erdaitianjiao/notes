### ebpf笔记

#### 一、什么是ebpf

eBPF 是一个能够在内核运行沙盒程序的技术，提供了一种在内核事件和用户程序事件发生时安全注入代码的机制，使得非内核开发人员也可以对内核进行控制。随着内核的发展，eBPF 逐步从最初的数据包过滤扩展到了网络、内核、安全、跟踪等，而且它的功能特性还在快速发展中，早期的 BPF 被称为经典 BPF，简称 cBPF，正是这种功能扩展，使得现在的 BPF 被称为扩展 BPF，简称 eBPF

#### 二、 ebpf的应用场景

##### 1. 网络优化

eBPF 兼具高性能和高可扩展特性，使得其成为网络方案中网络包处理的优选方案

1. **高性能**

   JIT 编译器提供近乎内核本地代码的执行效率

2. **高可扩展**

   在内核的上下文里，可以快速地增加协议解析和路由策略

##### 2. 故障诊断

eBPF 通过 kprobe，tracepoints 跟踪机制兼具内核和用户的跟踪能力，这种端到端的跟踪能力可以快速进行故障诊断，与此同时 eBPF 支持以更加高效的方式透出 profiling 的统计数据，而不需要像传统系统需要将大量的采样数据透出，使得持续地实时 profiling 成为可能

##### 3. 性能监控

相比于传统的系统监控组件比如 sar，只能提供静态的 counters 和 gauges，eBPF 支持可编程地动态收集和边缘计算聚合自定义的指标和事件，极大地提升了性能监控的效率和想象空间

#### 三、 ebpf 的特点 为什么会出现

1. 安全
2. 高效
3. 标准
4. 功能强大

#### 四、ebpf的使用过程

##### 1. 使用c语言开发程序

即插桩点触发事件时要调用的 eBPF 沙箱程序，该程序会在内核态运行

##### 2. 借助 LLVM 把 eBPF 程序编译成 BPF 字节码

eBPF 程序编译成 BPF 字节码，用于后续在 eBPF 虚拟机内验证并运行

##### 3. 通过 bpf 系统调用，把 BPF 字节码提交给内核

##### 4. 内核验证并运行 BPF 字节码，并把相应的状态保存到 BPF 映射中

内核验证 BPF 字节码安全，并且确保对应事件发生时调用正确的 eBPF 程序，如果有状态需要保存，则写入对应 BPF 映射中，比如监控数据就可以写到 BPF 映射中

##### 5. 用户程序通过 BPF 映射查询 BPF 字节码的运行状态

用户态通过查询 BPF 映射的内容，获取字节码运行的状态，比如获取抓取到的监控数据

﻿一个完整的 eBPF 程序，通常包含用户态和内核态两部分：用户态程序需要通过 BPF 系统调用跟内核进行交互，进而完成 eBPF 程序加载、事件挂载以及映射创建和更新等任务；而在内核态中，eBPF 程序也不能任意调用内核函数，而是需要通过 BPF 辅助函数完成所需的任务。尤其是在访问内存地址的时候，必须要借助 bpf_probe_read 系列函数读取内存数据，以确保内存的安全和高效访问。在 eBPF 程序需要大块存储时，我们还需要根据应用场景，引入特定类型的 BPF 映射，并借助它向用户空间的程序提供运行状态的数据



#### 五、ebpf的具体使用场景

##### 1. 跟踪 

tracepoint, kprobe, perf_event 等，主要用于从系统中提取跟踪信息，进而为监控、排错、性能优化等提供数据支撑

##### 2. 网络

xdp, sock_ops, cgroup_sock_addr , sk_msg 等，主要用于对网络数据包进行过滤和处理，进而实现网络的观测、过滤、流量控制以及性能优化等各种丰富的功能，这里可以丢包，重定向

##### 3. 安全和其他

lsm，用于安全，其他还有 flow_dissector, lwt_in 都是一些不怎么常用的，不再赘述



#### 六、ebpf的实现原理

##### 1）五个组成部分

###### 1. BPF Verifier（验证器）

确保 eBPF 程序的安全。验证器会将待执行的指令创建为一个有向无环图（DAG），确保程序中不包含不可达指令；接着再模拟指令的执行过程，确保不会执行无效指令，这里通过和个别同学了解到，这里的验证器并无法保证 100%的安全，所以对于所有 BPF 程序，都还需要严格的监控和评审

###### 2. BPF JIT

将 eBPF 字节码编译成本地机器指令，以便更高效地在内核中执行

###### 3. 多个 64 位寄存器、一个程序计数器和一个 512 字节的栈组成的存储模块

用于控制 eBPF 程序的运行，保存栈数据，入参与出参

###### 4. BPF Helpers（辅助函数）

提供了一系列用于 eBPF 程序与内核其他模块进行交互的函数。这些函数并不是任意一个 eBPF 程序都可以调用的，具体可用的函数集由 BPF 程序类型决定。注意，eBPF 里面所有对入参，出参的修改都必须符合 BPF 规范，除了本地变量的变更，其他变化都应当使用 BPF Helpers 完成，如果 BPF Helpers 不支持，则无法修改

~~~bash
bpftool feature probe
~~~

通过以上命令可以看到不同类型的 eBPF 程序可以运行哪些 BPF Helpers

###### 5. BPF Map & context

用于提供大块的存储，这些存储可被用户空间程序用来进行访问，进而控制 eBPF 程序的运行状态

~~~bash
bpftool feature probe | grep map_type
~~~

通过以上命令可以看到系统支持哪些类型的 map

#### 2）三个动作

先说下重要的系统调用 bpf

~~~c
int bpf(int cmd, union bpf_attr *attr, unsigned int size);
~~~

这里 cmd 是关键，attr 是 cmd 的参数，size 是参数大小



###### 1. 程序加载

调用 BPF_PROG_LOAD cmd，会将 BPF 程序加载到内核，但 eBPF 程序并不像常规的线程那样，启动后就一直运行在那里，它需要事件触发后才会执行。这些事件包括系统调用、内核跟踪点、内核函数和用户态函数的调用退出、网络事件，等等，所以需要第 2 个动作

###### 2. 绑定事件

~~~c
b.attach_kprobe(event="xxx", fn_name="yyy")
~~~

以上就是将特定的事件绑定到特定的 BPF 函数，实际实现原理如下：

（1）借助 bpf 系统调用，加载 BPF 程序之后，会记住返回的文件描述符；

（2）通过 attach 操作知道对应函数类型的事件编号；

（3）根据 attach 的返回值调用 perf_event_open 创建性能监控事件；

（4）通过 ioctl 的 PERF_EVENT_IOC_SET_BPF 命令，将 BPF 程序绑定到性能监控事件

###### 3. 映射操作

通过 MAP 相关的 cmd，控制 MAP 增删，然后用户态基于该 MAP 与内核状态进行交互



####  七、ebpf开发流程

- 定义 eBPF 程序的接口和类型：这包括定义 eBPF 程序的接口函数，定义和实现 eBPF 内核映射（maps）和共享内存（perf events），以及定义和使用 eBPF 内核帮助函数（helpers）

- 编写 eBPF 程序的代码：这包括编写 eBPF 程序的主要逻辑，实现 eBPF 内核映射的读写操作，以及使用 eBPF 内核帮助函数

  编译 eBPF 程序：这包括使用 eBPF 编译器（例如 clang）将 eBPF 程序代码编译为 eBPF 字节码，并生成可执行的 eBPF 内核模块。ecc 本质上也是调用 clang 编译器来编译 eBPF 程序。

- 加载 eBPF 程序到内核：这包括将编译好的 eBPF 内核模块加载到 Linux 内核中，并将 eBPF 程序附加到指定的内核事件上

- 使用 eBPF 程序：这包括监测 eBPF 程序的运行情况，并使用 eBPF 内核映射和共享内存进行数据交换和共享

- 在实际开发中，还可能需要进行其他的步骤，例如配置编译和加载参数，管理 eBPF 内核模块和内核映射，以及使用其他高级功能

#### 八、环境配置和编译运行

1. 环境配置

2. 编译运行

   ~~~bash
   ./ecc minimal.bpf.c
   sudo ./ecli run package.json
   ~~~



#### 九、知识

##### 1. kprobe

它允许你在 **内核代码的任意指令处** 动态插入“探测点（probe）”，当该代码执行到探测点时，**会自动触发你的回调函数**

##### 2. fentry

fentry（function entry）和 fexit（function exit）是 eBPF（扩展的伯克利包过滤器）中的两种探针类型，用于在 Linux 内核函数的入口和退出处进行跟踪。它们允许开发者在内核函数执行的特定阶段收集信息、修改参数或观察返回值。这种跟踪和监控功能在性能分析、故障排查和安全分析等场景中非常有用

##### 3. 过滤进程pid

在运行程序时候 可以使用 `--pid_target`来指定要捕获的进程的pid

~~~bash
sudo ./ecli run package.json --pid_target 838
~~~

##### 4. uprobe

uprobe是一种用户空间探针，uprobe探针允许在用户空间程序中动态插桩，插桩位置包括：函数入口、特定偏移处，以及函数返回处。当我们定义uprobe时，内核会在附加的指令上创建快速断点指令（x86机器上为int3指令），当程序执行到该指令时，内核将触发事件，程序陷入到内核态，并以回调函数的方式调用探针函数，执行完探针函数再返回到用户态继续执行后序的指令

##### 5. pref buffer 

eBPF 提供了两个环形缓冲区，可以用来将信息从 eBPF 程序传输到用户区控制器。第一个是perf环形缓冲区，，它至少从内核v4.15开始就存在了。第二个是后来引入的 BPF 环形缓冲区。本文只考虑perf环形缓冲区

##### 6. ring buffer

现在有一个新的 BPF 数据结构可用，eBPF 环形缓冲区（ring buffer）。它解决了 BPF perf buffer（当今从内核向用户空间发送数据的事实上的标准）的内存效率和事件重排问题，同时达到或超过了它的性能。它既提供了与 perf buffer 兼容以方便迁移，又有新的保留/提交API，具有更好的可用性。另外，合成和真实世界的基准测试表明，在几乎所有的情况下，所以考虑将其作为从BPF程序向用户空间发送数据的默认选择

##### 7. runqlat

runqlat 是一个 eBPF 工具，用于分析 Linux 系统的调度性能。具体来说，runqlat 用于测量一个任务在被调度到 CPU 上运行之前在运行队列中等待的时间。这些信息对于识别性能瓶颈和提高 Linux 内核调度算法的整体效率非常有用

##### 8. hardirqs 和 softirqs

