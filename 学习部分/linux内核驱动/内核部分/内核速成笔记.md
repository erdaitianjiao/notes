### 内核笔记 速成版

#### 一、内核中的 进程调度机制（Scheduler）

调度器主流调度室使用 **CFS（Completely Fair Scheduler）**

- CFS思想

  > 不再使用时间片轮转，而是维护一个“虚拟运行时间”（vruntime），让所有任务公平地共享 CPU。

  - 每个可运行任务都有一个 `vruntime`（虚拟运行时间）
  - 谁的 `vruntime` 最小，谁最该被调度（即“欠CPU时间最多”）
  - 优先级高的任务，`vruntime` 增长得慢，因此更容易被调度
  - 数据结构：**红黑树**（`rb_leftmost` 为当前最应该运行的任务）

- 关键数据结构

  ~~~c
  struct sched_entity {
      struct load_weight load;     // 任务权重（优先级）
      u64 vruntime;                // 虚拟运行时间
      struct rb_node run_node;     // 在红黑树中节点
      struct task_struct *task;    // 关联进程
  };
  ~~~

  

#### 二、CPU 核迁移（CPU Migration）

###### 1. 何为迁移

迁移（migration）指任务从一个 CPU 运行队列（`runqueue`）移动到另一个 CPU 的 `runqueue`。

##### 2. 为什么要迁移

- 某个 CPU 太忙，而其他核空闲 -> 负载均衡（load balancing）
- 任务被唤醒时，更靠近其数据缓存的 CPU → 缓存局部性（cache affinity）
- cpuset / CPU 热插拔 / NUMA 策略

##### 3. 关键机制

###### `load_balance()` 负载均衡

周期性由调度器 tick 调用，尝试把任务从繁忙 CPU 拉到空闲 CPU。

###### `wake_affine` 唤醒迁移

当任务从睡眠中被唤醒时，调度器会判断是否让它在原 CPU 上运行（以利用缓存），还是迁移到当前 CPU。

###### NUMA-aware Balancing

NUMA 系统中还要考虑内存节点亲和性（memory locality），
 CFS 在调度时会尝试将任务留在最优内存节点附近。



#### 三、使用 eBPF 观测调度与迁移

##### 1. 为什么用 eBPF

传统 perf/top 只能统计频率或采样，eBPF 可以直接在内核 tracepoint、kprobe、sched hook 上动态插桩，**实时追踪调度事件**。

##### 2. 常用观测点（tracepoints）

| Tracepoint                 | 说明               |
| -------------------------- | ------------------ |
| `sched:sched_switch`       | 进程切换（最常用） |
| `sched:sched_wakeup`       | 任务被唤醒         |
| `sched:sched_migrate_task` | 任务迁移到其他CPU  |
| `sched:sched_process_exit` | 进程退出           |
| `sched:sched_process_fork` | 创建进程           |

##### 3. 常见 eBPF 程序示例

###### (1) 捕获进程切换

```c
SEC("tracepoint/sched/sched_switch")
int on_sched_switch(struct trace_event_raw_sched_switch *ctx)
{
    u32 prev_pid = ctx->prev_pid;
    u32 next_pid = ctx->next_pid;
    u32 cpu = bpf_get_smp_processor_id();

    bpf_printk("CPU %d: switch %d -> %d\n", cpu, prev_pid, next_pid);
    return 0;
}
```

###### (2) 捕获迁移事件

```c
SEC("tracepoint/sched/sched_migrate_task")
int trace_migrate(struct trace_event_raw_sched_migrate_task *ctx)
{
    bpf_printk("PID %d migrated from CPU %d to %d\n",
               ctx->pid, ctx->orig_cpu, ctx->dest_cpu);
    return 0;
}
```

可以用 `bpftool`, `bcc` 或 `libbpf` 加载运行。

