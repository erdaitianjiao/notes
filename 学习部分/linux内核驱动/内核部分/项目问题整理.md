## Tiny-os

### 请你简单介绍一下 Tiny-OS 项目？

回答方向：

- 项目目标、主要模块、实现成果。

参考答案：
 Tiny-OS 是我基于 x86 架构自制的一个 32 位操作系统原型，参考《操作系统真象还原》实现。
 它包括从引导加载、内存管理、任务调度到文件系统和 Shell 的完整系统流程。
 我自己从零实现了 MBR 引导、GDT/IDT、中断管理、分页机制、多任务调度和文件系统等核心模块，并能在 Bochs 虚拟机上独立运行。



### 系统从上电到进入内核模式的过程是怎样的？

回答方向：

- BIOS → MBR → Bootloader → Kernel → main
- 实模式 → 保护模式的切换

参考答案：
 系统上电后，BIOS 会加载 MBR（512 字节引导扇区）到 0x7C00。
 在 MBR 中我完成了加载二级引导器和内核镜像的功能。
 然后通过配置 GDT，打开 A20 地址线，设置 CR0 寄存器进入保护模式。
 进入保护模式后跳转到 C 语言编写的内核初始化函数，开始内存管理、任务调度等初始化。



### 你是如何实现从实模式到保护模式切换的？

回答方向：

- 设置 GDT，加载 GDTR，修改 CR0.PE 位。

参考答案：
 首先我定义了 GDT 表，包含代码段、数据段、显存段等描述符。
 然后使用 `lgdt` 加载 GDT 地址，打开 A20 地址线以支持 1MB 以上寻址。
 接着通过 `mov cr0, eax` 设置 PE 位为 1，CPU 切换到保护模式，最后用长跳转刷新流水线并正式进入保护模式。



### 你的分页机制是怎么实现的？

回答方向：

- 页目录、页表、4KB 页映射。
- 虚拟地址到物理地址映射。

参考答案：
 我实现了二级页表结构，每个页表项映射 4KB 空间。
 在内核初始化阶段分配一块物理内存用于页目录和页表，然后把虚拟地址空间映射到对应物理地址。
 页目录地址加载到 CR3，最后设置 CR0 的 PG 位开启分页。
 这样 CPU 在访问虚拟地址时会通过页目录与页表完成地址转换，实现虚拟内存管理。



### 分页机制带来了什么好处？

回答方向：

- 内存隔离、内存保护、方便分配、支持虚拟内存。

参考答案：
 分页机制能把逻辑地址和物理地址分离，实现不同进程间的内存隔离。
 同时方便做内存映射与换页，避免程序直接访问物理地址造成冲突。
 在多任务系统中，这是内存安全和稳定运行的基础。



### 你实现的多任务调度是怎么工作的？

回答方向：

- 时间片轮转算法 + TSS 任务切换。

参考答案：
 我使用了时间片轮转调度算法（Round Robin）。
 通过时钟中断周期性触发调度函数，切换当前运行任务。
 每个任务有自己的内核栈、寄存器上下文、页表信息等。
 任务切换通过保存和恢复寄存器状态实现，并使用 TSS（任务状态段）进行用户态与内核态切换。



### 你是如何实现中断机制的？

回答方向：

- IDT 表配置，中断描述符加载，ISR 编写。

参考答案：
 我在初始化阶段设置了 IDT（中断描述符表），每个中断向量对应一个中断服务例程（ISR）。
 通过 `lidt` 加载 IDT，之后 CPU 发生中断会自动跳转到相应的处理函数。
 在中断入口我用汇编保存寄存器现场，处理完毕后再恢复，保证任务上下文完整。



### 用户态和内核态是怎么切换的？

回答方向：

- 通过中断门、TSS、堆栈切换。

参考答案：
 我在 GDT 中定义了用户态代码段和数据段，并设置了 TSS（任务状态段）用于保存内核栈地址。
 当用户态程序通过系统调用触发中断（例如 int 0x80）时，CPU 根据 TSS 自动切换到内核栈执行内核代码，
 处理完再通过 `iret` 返回用户态。
 这样能保证内核和用户空间的安全隔离。



### 你设计的文件系统是怎样的？

回答方向：

- 模拟 FAT32，含 inode、目录项、数据区。

参考答案：
 我设计了一个仿 FAT32 的文件系统结构，包含超级块、FAT 表、inode 表、数据区等部分。
 每个文件有对应的 inode，记录文件大小、起始块号等信息。
 通过链式 FAT 表管理文件分配，实现了文件的创建、删除、读写和目录操作。



### 文件系统如何与内核交互？

回答方向：

- 通过系统调用接口读写。

参考答案：
 内核提供系统调用接口（如 open、read、write），Shell 或用户程序通过这些接口访问文件系统。
 内核再根据 inode 索引和 FAT 表执行实际的磁盘读写操作。
 整个过程由中断机制保证用户态与内核态的安全切换。



### 你的 Shell 是如何实现的？

回答方向：

- 基于命令解析与系统调用。

参考答案：
 Shell 是我在用户态编写的一个简单命令解析器。
 它通过系统调用访问内核资源，支持命令如 `ls`、`cd`、`ps`、`cat` 等。
 命令输入通过键盘中断获取，解析后执行相应函数或系统调用。



### 这个项目中你遇到的最大难点是什么？怎么解决的？

回答方向：

- 选择一个真实问题，如分页异常、任务切换 bug、中断失效等。

参考答案：
 我遇到的最大问题是创建文件经常发生缺页异常

后来我发现是打开inode的时候没有处理 从链表元素 `elem` 找到它所属的 `struct inode` 结构体

导致指针指向不知道的地址，导致缺页异常



### 这个项目让你最大的收获是什么？

参考答案：
 通过这个项目，我深入理解了操作系统从“引导 → 内存管理 → 任务调度 → 文件系统”的完整运行机制。
 同时掌握了 x86 架构下的汇编、段式与分页内存管理、内核栈切换、系统调用等底层原理，
 对今后的驱动开发和内核调试帮助很大。



### 如果让你继续完善 Tiny-OS，你想做什么？

参考答案：
 我希望进一步完善系统调用机制和用户进程管理，
 增加 ELF 可执行文件加载功能，
 同时优化调度算法，让多任务更稳定。
 最终目标是让它能运行简单的多进程用户程序。



## Linux Driver

