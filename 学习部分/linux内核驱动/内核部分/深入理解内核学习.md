### linux内核学习

#### 一、内存寻址

##### 1. 内存地址

内存地址分为三个

1. 逻辑地址
2. 线性地址 (虚拟地址)
3. 物理地址

**逻辑地址经过分段单元变成线性地址， 线性地址经过分页单元变成物理地址**

##### 2. 分段管理

一个逻辑地址由两个必不可少的部分构成，就像写信需要“省市区”和“街道门牌号”一样：

1. **段选择符**
2. **偏移量**

格式为：段选择符:偏移量

######  1) 段选择符 确定“哪个段"

这是一个**16位**的字段，它的作用不是直接给出段的地址，而是作为一个“索引”或“钥匙”，告诉CPU去哪里找到这个段的详细信息（比如段从哪里开始、有多大、有什么权限）

- **索引号** <br>这是选择符中最重要的部分，占13位（位3到位15）。它可以索引8192个条目。CPU用它来在**描述符表**中定位具体的段描述符<br>计算方法是：`索引号 * 8`（因为每个段描述符占8个字节）
- **表指示器**：占1位（位2，即TI）<br>**TI = 0**：表示去**全局描述符表** 中查找段描述符。GDT包含所有程序（包括操作系统本身）都能使用的段<br>**TI = 1**：表示去**局部描述符表** 中查找段描述符。LDT通常是为某个特定任务或程序私有的
- **请求者特权级**占2位（位0和位1，即RPL）<br>它表示当前请求访问这个段的程序的权限级别（0到3级，0级是最高权限的内核态，3级是最低权限的用户态）。这主要用于硬件级别的安全保护，防止低权限程序访问高权限数据

###### 2) 段寄存器 确定“段内具体位置”

这是一个**32位**的字段。它指定了您要访问的内存位置距离所在**段起始处**的字节距离

- 因为它是32位，所以一个段的最大长度可达 2^32 = 4GB

- 一旦通过段选择符找到了段的**基地址**（起始地址），CPU只需要执行一个简单的操作：`线性地址 = 段基地址 + 偏移量`，就能得到最终的线性地址

###### 3)  段描述符 段在内存中的描述

- 它描述了一个内存段的全部特征：这个段从哪里开始（基地址），有多大（段界限），是什么类型的（代码段还是数据段），有什么权限（谁可以访问）等
- **它是一个8字节（64位）的数据结构**。所有段的描述符都集中存放在**全局描述符表（GDT）** 或**局部描述符表（LDT）** 中



| 字段名                  | 核心作用解释                                                 |
| :---------------------- | :----------------------------------------------------------- |
| **Base（基地址）**      | **段的“起始位置”**。这是一个32位的值，定义了段在4GB线性地址空间中的开始地址。转换公式：`线性地址 = Base + 偏移量`。 |
| **G（粒度）**           | **决定段限长单位是“字节”还是“页”**。这是与**Limit**字段配合使用的关键标志。 • **G=0**：Limit的单位是**字节**。此时段大小最大为1MB。 • **G=1**：Limit的单位是**4KB（一页）**。此时段大小最大为4KB * 1M = 4GB。 |
| **Limit（段界限）**     | **段的“长度”或“边界”**。它表示段内最后一个合法偏移量与基地址的距离。CPU会检查程序的偏移量是否小于等于Limit，如果超出则产生“一般保护异常”，防止内存越界访问。 |
| **S（系统标志）**       | **区分“系统段”和“普通段”**。 • **S=0**：这是一个**系统段**。用于存储操作系统关键数据结构，如LDT、任务状态段（TSS）。 • **S=1**：这是一个**普通段**，即常见的代码段或数据段。 |
| **Type（类型）**        | **定义段的详细类型和访问权限**。例如，是代码段（可执行）还是数据段（可读写），以及该段是否已被访问过等。 |
| **DPL（描述符特权级）** | **段的“门禁等级”**。值为0-3，0为最高权限（内核态），3为最低权限（用户态）。当程序的当前特权级（CPL）低于（数字上大于）DPL时，程序无权访问该段。这实现了内核数据对用户程序的保护。 |
| **P（存在标志）**       | **指示段是否在物理内存中**。P=0表示该段被交换到了硬盘上（交换分区），访问它会导致缺页异常，由操作系统将其换入内存。**但图片提到，Linux总是设置P=1**，因为Linux不以整个段为单位进行交换，而是以更细粒度的“页”为单位。 |
| **D/B（默认操作大小）** | **指定默认的地址和操作数大小**。对于代码段，D=1表示指令使用32位偏移量，D=0表示使用16位偏移量。对于栈段（由SS寄存器指向），B=1表示使用32位栈指针（ESP），B=0表示使用16位栈指针（SP）。 |
| **AVL标志**             | **一个“可用”标志**，留给操作系统自由使用，但Linux内核忽略此标志。 |

###### 4) 段选择器

分段单元是CPU内存管理单元（MMU）中的一个专用硬件电路，它的核心职责是完成内存地址转换的第一步：将逻辑地址转换为线性地址

- 第一步：判断描述符表
- 第二步：计算段描述符地址
- 第三步：生成线性地址

安全检查

- **界限检查**：确保偏移量没有超过段描述符中定义的段界限。
- **权限检查**：确保当前程序的权限级别有资格访问这个段。

##### 3. Linux分段

###### 1) 全局描述符GDT

**全局描述符表（GDT）** 是 x86 保护模式下内存管理的基础。它是一个由操作系统维护的数组，数组中的每一项都是一个**段描述符**（8字节的数据结构），它描述了一个内存段的关键属性（如基地址、长度、权限等）<br>

CPU 通过**段选择符** 来索引 GDT，从而找到对应的段描述符，完成逻辑地址到线性地址的转换

- GPT关键特性

  1. GDT 的管理：每 CPU 一份

     - **关键点**：在**多处理器（SMP）系统**中，**每个 CPU 都有自己独立的 GDT 副本**
     - 每个 CPU 都需要一些独享的资源。最典型的例子就是**任务状态段（TSS）**。每个 CPU 都需要一个独立的 TSS 来存储它当前运行任务的内核态栈等信息

  2. GDT 的布局

     | 类别             | 描述符                     | 说明                                                         |
     | :--------------- | :------------------------- | :----------------------------------------------------------- |
     | **核心段**       | Null, 保留项               | 第一项必须为 0（空描述符），还有一些保留项。                 |
     |                  | **内核代码段、内核数据段** | 定义内核的代码和数据段，DPL=0（最高权限）。                  |
     |                  | **用户代码段、用户数据段** | 定义用户程序的代码和数据段，DPL=3（用户权限）。这是实现用户态和内核态隔离的基础。 |
     | **每 CPU 资源**  | **任务状态段（TSS）**      | **每个 CPU 一个**。这是 GDT 因 CPU 而异的主要原因之一。TSS 用于存储任务切换时的硬件上下文和内核栈指针，对每个 CPU 都是唯一的。 |
     | **进程相关资源** | **缺省 LDT 段**            | 指向一个通常被所有进程共享的缺省局部描述符表。               |
     |                  | **线程局部存储（TLS）段**  | 3 个 TLS 段，允许线程拥有自己私有的数据段。**这些项依赖于正在执行的进程**，不同进程的 TLS 设置不同。 |
     | **特殊功能**     | **高级电源管理（APM）段**  | 3 个段。当内核调用 BIOS 的 APM 功能时，需要临时切换到 BIOS 期望的特定代码段和数据段。 |
     |                  | **即插即用（PnP）BIOS 段** | 5 个段。与 APM 类似，用于调用 PnP BIOS 服务。                |
     |                  | **双重错误处理 TSS**       | 一个特殊的 TSS，用于处理非常严重的“双重错误”异常。           |

  3. GDT 的动态性

     多数情况下，一个 CPU 的 GDT 内容是稳定的

     1. **进程相关**：当进程切换时，如果新进程使用了 TLS，那么对应 CPU 的 GDT 中那 3 个 TLS 描述符需要被更新为新进程的值
     2. **临时修改**：当内核需要调用 BIOS 例程（如 APM）时，可能会**临时修改** GDT 中的对应项，以满足 BIOS 的调用约定，调用结束后再恢复

###### 2) 局部描述符 LDT

LDT 是 GDT（全局描述符表）的补充，用于为单个进程定义私有的内存段。而 Linux 的策略是：绝大多数情况下不使用 LDT，仅在极少数特殊场景下才允许进程创建

##### 4. 硬件中的分页

分页的核心思想是 **将线性地址空间和物理内存都划分为固定大小的块，通过页表建立映射关系**

###### 1) 基本概念

1. **页**：进程视角的内存块。它是**线性地址空间**中被划分为固定大小的单位（如4KB）。一个页就是一串连续的线性地址
2. **页框**：硬件视角的内存块。它是**物理内存（RAM）** 中被划分为与页大小相同的单位。每个页框可以存放一个页的内容。

- **关键区别**：页是“虚拟”的，是一个地址范围；页框是“物理”的，是真正的内存芯片单元。一个页的数据可以存放在任何一个可用的页框中，甚至可以暂时被换出到磁盘上

###### 2) 工作原理

1. **分页单元**：这是CPU中内存管理单元（MMU）的一部分，专门负责将**线性地址**转换为**物理地址**。它的工作就是查表（页表）和转换

2. **页表**：这是实现映射的“总目录”或“地址转换表”。它是由操作系统内核创建并维护的数据结构，存放在物理内存中

   - **页表项**：页表由无数个“页表项”组成。每个页表项至少包含两个关键信息
     - **物理页框号**：指示该页数据实际存放在哪个物理页框中
     - **访问权限位**：例如，该页是否可读、可写、可执行

3. **地址转换过程**

   - CPU为一个进程执行指令，需要访问一个线性地址
   - MMU中的分页单元会“截获”这个线性地址
   - 它将线性地址拆解为两部分：**页号** 和 **页内偏移量**
   - 分页单元使用**页号**作为索引，去查询当前进程的页表，找到对应的页表项
   - 从页表项中读出**物理页框号**
   - 最后，将**物理页框号**和原始的**页内偏移量**组合起来，就得到了最终的**物理地址**

4. **权限检查与缺页异常**

   - 在转换的同时，分页单元会将访问请求（例如是读操作还是写操作）与页表项中的**访问权限**进行比对

   - 如果程序没有权限（例如尝试写入一个“只读”页），分页单元会触发一个**硬件异常**，即“缺页异常”，由内核接管处理，通常会终止该程序

     如果权限正确，则完成转换，访问物理内存

###### 3) 硬件高速缓存

- 为什么需要硬件高速缓存

  现代CPU的时钟频率高达数GHz，而动态RAM（DRAM）的存取速度则慢数百倍。如果CPU每次都需要直接访问RAM来读取指令或数据，那么大部分时间都会在等待中浪费，形成性能瓶颈。硬件高速缓存就是为了**缩小这一速度差距**而引入的

- 硬件高速缓存是什么

  硬件高速缓存是一小块但速度极快的静态RAM（SRAM），通常直接集成在CPU芯片内部（称为L1、L2缓存等）。它的存在基于**局部性原理**

  1. **时间局部性**：最近被访问过的数据，很可能在不久的将来再次被访问
  2. **空间局部性**：如果一个内存位置被访问，那么它邻近的位置也很可能在不久后被访问

- **地址解析与缓存访问（命中与未命中）**

  - **偏移量**：定位行内的具体字节。
  - **索引**：在高速缓存中定位到对应的“组”。
  - **标签**：在找到的“组”中，与所有行的**标签** 进行比较

  - **缓存命中**：如果比较发现某个行的标签与地址的标签部分匹配，则说明所需数据已在缓存中。CPU直接从高速缓存中读取数据，无需访问慢速的RAM，效率极高
  - **缓存未命中**：如果标签不匹配，则数据不在缓存中。这时，缓存控制器需要执行以下操作：如果必要（如该缓存行被修改过），将当前占位的旧行**写回**主内存（针对回写策略）。从主内存中把包含目标数据的新行**载入**到高速缓存的对应位置。然后CPU才能从缓存中访问到该数据

- 写策略：通写  vs  回写

  当CPU执行**写操作**且缓存命中时，有两种策略：

  - **通写**：同时写入高速缓存行和主内存。简单可靠，但每次写操作都要等待慢速的RAM，降低了速度。
  - **回写**：只更新高速缓存行，并将其标记为“脏”。主内存只在**该行被替换出缓存时**才被更新。这种方式更快，因为多次写操作可以合并为一次内存更新，但控制更复杂。Linux默认偏好回写策略以提升性能

- **多处理器系统中的缓存一致性**

  每个处理器都有自己的本地缓存，但内存是共享的。

  - **问题**：如果CPU 0修改了其缓存中某个共享数据的副本，而CPU 1的缓存中还是旧副本，就会导致数据不一致
  - **解决方案**：通过额外的硬件电路（如**缓存侦听**协议）来自动保持所有缓存同步。当一个CPU修改其缓存数据时，硬件会自动通知其他CPU，使它们缓存中的对应数据**无效**或**更新**。这一切对操作系统内核是透明的

-  Linux操作系统的角色

  1. **策略设置**：通过控制CPU的`CR0`寄存器来全局启用/禁用缓存，或设置写策略
  2. **页级控制**：页表项中有标志位（PCD, PWT）可以针对每个内存页单独设置缓存策略。但**Linux为了追求最佳性能，默认对所有页启用缓存并使用回写策略**
  3. **忽略细节**：Linux无需关心多级缓存（L1, L2, L3）之间或不同CPU缓存之间的具体同步细节，这些全部由硬件自动完成

##### 5. 二级分页

###### 1) 分页的作用

分页的主要目的是实现**虚拟内存**。它让每个进程都认为自己拥有一大片连续、独立的内存空间（如4GB），而实际上这些内存可能被零散地映射到物理内存的不同位置，甚至有一部分暂时存储在硬盘上。这带来了内存保护、进程隔离和更高效的物理内存利用等巨大好处

###### 2) 二级分页结构

1. **线性地址（虚拟地址）**：就像你要找的书号是 `05-12-103`。这个地址被规则地划分为三部分：
   - **目录（Directory）**：最高10位，相当于 `05`，代表第5个书架区。
   - **页表（Table）**：中间10位，相当于 `12`，代表该区的第12个书架。
   - **偏移量（Offset）**：最低12位，相当于 `103`，代表该书架上的第103本

- 为什么需要二级

为了节省内存。如果一级映射，需要一张拥有100多万个表项的巨大页表。而二级模式可以**按需分配**，进程只用到了哪些虚拟内存区域，才为那些区域创建页表，大大减少了内存开销

###### 3) 页表项/页目录项

| 标志位                      | 核心作用与含义                                               |
| :-------------------------- | :----------------------------------------------------------- |
| **P（Present，存在位）**    | **最重要的标志**。为1表示该页已在物理内存中；为0表示不在内存中（可能在硬盘上）。如果访问P=0的页，会触发**缺页异常**，由操作系统介入处理（如从硬盘换入页面）。 |
| **R/W（读/写）**            | 为0表示该页只读；为1表示可读可写。用于硬件级别的内存保护。   |
| **U/S（用户/超级用户）**    | 为0表示该页只能由内核态（特权级0、1、2）访问；为1表示用户态（特权级3）也可访问。这是实现用户态和内核态隔离的基础。 |
| **A（Accessed，访问位）**   | 每当CPU访问（读或写）该页时，硬件会自动将其置1。**操作系统通过此位来判断哪些页是活跃的**，以便在需要换出页面时做出选择。硬件不自动清零，需由操作系统软件清零。 |
| **D（Dirty，脏位）**        | **仅存在于页表项中**。当CPU对该页进行**写操作**时，硬件将其置1。这表明页的内容已被修改，与硬盘上的备份不一致。**在换出此页时，操作系统必须将其写回硬盘**。如果只是读，则不会置位。 |
| **PS（Page Size，页大小）** | **仅存在于页目录项中**。为0表示使用4KB小页；为1表示该页目录项直接指向一个2MB或4MB的大页，从而跳过页表查询，提升大内存块访问效率。 |
| **其他（PWT, PCD, G）**     | 与控制硬件缓存（TLB、CPU Cache）行为相关的标志。             |

##### 6. Linux中的分页

###### 1) Linux分页模型

Linux 设计了一套**通用（抽象）的分页模型**。这套模型的核心是定义一个**四级页表结构**，使得内核的内存管理代码能够以一种统一的方式与不同硬件交互

- **四级页表结构**

  1. **页全局目录（Page Global Directory, PGD）**
  2. **页上级目录（Page Upper Directory, PUD）**
  3. **页中间目录（Page Middle Directory, PMD）**
  4. **页表（Page Table, PT）**

- **地址转换过程**

  一个线性地址（虚拟地址）被相应地划分为多个部分（通常是索引和偏移量）。转换时，MMU 依次进行查表：

  - 用 **PGD 索引** 在 PGD 中找到对应的表项，该项指向一个 PUD
  - 用 **PUD 索引** 在 PUD 中找到对应的表项，该项指向一个 PMD
  - 用 **PMD 索引** 在 PMD 中找到对应的表项，该项指向一个 PT
  - 用 **PT 索引** 在 PT 中找到对应的**页表项（PTE）**，该项包含了数据所在的**物理页框号**
  - 最后，将物理页框号与地址中的**页内偏移量**组合，得到最终的**物理地址**

- **应对不同硬件**

  - **针对 32 位系统（无 PAE）**：<br>此类硬件只需两级页表（页目录和页表）即可。Linux 的做法是：将 **PUD** 和 **PMD** 的索引位宽定义为 **0**。<br>在代码中，PUD 和 PMD 被处理为**只包含一个表项**，并且这个表项直接指向下一级的起始地址。<br>这样，在转换过程中，查 PUD 和 PMD 就变成了“走过场”，实际效果等同于硬件原有的两级分页。<br>**同样的内核代码无需修改就能在不同架构上运行。**
  - **针对 64 位系统**：如 x86_64 架构，其硬件本身就使用四级分页，Linux 的四级模型可以与之直接对应。

- **分页机制的特性**

  1. **进程隔离**：每个进程都有自己独立的一套页表。当内核进行**进程切换**时，一个关键步骤就是将 CPU 中 `cr3`（x86架构）寄存器的值更新为**新进程的 PGD 的物理地址**。这样，当新进程开始执行时，分页单元会自动使用它的页表进行地址转换，从而访问它自己的独立内存空间，实现了完美的隔离。
  2. **虚拟内存**：分页机制使得“页”（虚拟内存单位）和“页框”（物理内存单位）可以分离。一个页的数据可以暂时存放在磁盘上，当需要时再装入任何一个空闲的物理页框中。这是现代操作系统虚拟内存（如交换空间）的基石



#### 二、进程

##### 1. 进程描述符

**进程描述符是内核用于管理和描述一个进程所有信息的数据结构**。每个进程都有一个唯一的 `task_struct`实例。内核正是通过遍历所有进程的 `task_struct`来对它们进行调度和管理的

###### 1) 构成

`task_struct`结构体的部分字段列表

这些是直接内嵌在 `task_struct`中的基本属性：

- `state`：**进程状态**。如可运行态（TASK_RUNNING）、睡眠态（TASK_INTERRUPTIBLE）、停止态（TASK_STOPPED）等。这是内核调度器决定是否运行该进程的关键依据。
- `thread_info`：一个指向 **`thread_info`** 结构体的指针。这个结构体非常关键，它通常与进程的内核栈存放在一起，包含了进程在底层硬件级别运行所需的信息（如寄存器状态）。它也是快速获取当前进程 `task_struct`的入口。
- `pid`：**进程标识符**。一个唯一的整数，用于在系统中标识该进程。
- `flags`：**进程标志**。描述进程的当前属性，例如进程是否正在被跟踪（PF_TRACED）。
- `ptraced`：指向一个**链表**的头，该链表链接了所有正在**被调试器跟踪（ptrace）** 的子进程。
- `mm`：一个指向 **`mm_struct`** 结构体的指针。该结构体**完整描述了进程的虚拟地址空间**，如代码段、数据段、堆栈的布局等。这是内存管理的核心。
- `fs`：描述进程的**文件系统信息**，如当前工作目录和根目录。
- `files`：一个指向 **`files_struct`** 结构体的指针。该结构体包含了进程所有**已打开文件描述符的表**（即文件句柄数组）。通过它，内核知道进程打开了哪些文件。
- `signal`：一个指向 **`signal_struct`** 结构体的指针。该结构体管理进程收到的**信号**，如定义当进程收到 SIGINT（Ctrl+C）信号时应执行什么处理函数。

`task_struct`关联的主要数据结构

这部分展示了 `task_struct`如何通过指针指向其他专门的数据结构，以管理进程的特定资源。这种“**主结构体 + 专用子结构体**”的设计使得内核代码结构清晰、易于维护。

1. **`thread_info`**：与进程执行上下文紧密相关，存放于内核栈底，用于快速访问当前进程和保存硬件上下文。
2. **`mm_struct`**：**内存描述符**。定义了整个进程的虚拟内存布局，是“进程独立地址空间”概念的实现者。
3. **`fs_struct`**：包含进程的文件系统环境信息。
4. **`files_struct`**：**文件描述符表**。进程通过它来访问所有打开的文件、套接字等。
5. **`signal_struct`**：**信号处理结构**。管理信号的处理方式和信号队列。

###### 2) 进程状态

进程描述符中的`state`字段描述了当前进程的状态，在当前linux版本中，这些状态是互斥的，只能设置一个状态

- TASK_RUNNING（可运行态 ）

  进程**正在 CPU 上执行**或位于运行队列中**准备执行**。这是进程被调度器选择运行时的状态

- TASK_INTERRUPTIBLE（可中断的等待状态）

  进程因等待某个条件（如 I/O 完成、信号量）而**睡眠（挂起）**。在条件满足前不会被调度。**关键**：此状态可被**信号**唤醒

- ASK_UNINTERRUPTIBLE（不可中断的等待状态）

  与上一种类似，也是睡眠状态。但**关键区别**在于，它**不会因接收到信号而被唤醒**。<br>用于必须完成、不可中断的内核操作（如某些硬件设备操作），以避免系统状态不一致。

- TASK_STOPPED（暂停状态）

  进程的**执行被暂停**，通常由信号（如 `SIGSTOP`, `SIGTSTP`）引发，并且需要由信号（如 `SIGCONT`）来恢复运行

- TASK_TRACED（跟踪状态）
  进程的执行被**调试器（如 gdb）暂停**，以便进行跟踪和调试。任何信号都可以导致进程进入此状态 

- EXIT_ZOMBIE（僵死状态）

  进程已终止，但其**进程描述符仍被保留**，直到其父进程通过 `wait()`系统调用读取其退出状态。此时进程占有的资源已释放，但内核仍需保留其退出信息

- EXIT_DEAD（僵死撤销状态）

  这是进程的**最终状态**。当父进程调用 `wait()`获取了子进程的退出信息后，系统将子进程状态从 EXIT_ZOMBIE 改为 EXIT_DEAD，随后便可彻底回收其所有资源。此状态用于防止在等待过程中出现竞争条件

切换进程状态的方法

1. 直接赋值

   ~~~c
   p->state = TASK_RUNNING;
   ~~~

2. 使用宏

   ~~~c
   set_task_state(task, state);	// 设置指定进程的状态。
   set_current_state(state);		// 设置当前正在执行的进程的状态
   ~~~

###### 3) 进程链表



###### 4) 进程关系

进程关系分为亲属关系和非亲属关系

- 亲属关系

  亲属关系描述了由 `fork()`系统调用创建的原始父子进程链及其衍生关系

  | 字段名            | 核心作用与含义                                               |
  | :---------------- | :----------------------------------------------------------- |
  | **`real_parent`** | **“生父”**。指向真正调用 `fork()`创建本进程的那个父进程的描述符。如果生父进程已终止，此指针会指向 `init`进程（PID 1）。 |
  | **`parent`**      | **“养父”**。指向当前需要接收本进程终止信号的父进程。通常与 `real_parent`相同，但在使用 `ptrace()`进行调试时，会变为调试进程。 |
  | **`children`**    | **“子进程链表头”**。指向一个链表的头部，该链表包含了本进程创建的所有**直接子进程**。 |
  | **`sibling`**     | **“兄弟指针”**。用于将本进程链接到其兄弟进程（即共享同一个 `real_parent`的其他进程）组成的双向链表中。 |

- 非亲属关系

  非亲属关系用于将进程组织成不同的功能单元，以实现作业控制、信号发送、多线程协作和调试等功能

- | 字段名                | 核心作用与含义                                               |
  | :-------------------- | :----------------------------------------------------------- |
  | **`group_leader`**    | **进程组领头进程**。指向本进程所在的**进程组**的领头进程。进程组用于 Shell 的作业控制（如前后台作业切换）。 |
  | **`signal->pgrp`**    | **进程组ID**。存储本进程所在进程组的领头进程的 **PID**。用于向整个进程组发送信号（如 `kill -PGID`）。 |
  | **`tgid`**            | **线程组ID**。对于多线程应用，此字段是所有线程共享的**线程组领头进程的PID**。用户空间看到的进程PID其实就是 `tgid`。这是实现POSIX线程的基础。 |
  | **`signal->session`** | **登录会话ID**。存储本进程所在的**登录会话**的领头进程的 **PID**。一个会话通常对应一个终端登录，包含多个进程组。 |
  | **`ptrace_children`** | **被跟踪的子进程链表**。如果本进程是调试器，此链表包含所有被它跟踪的子进程。 |
  | **`ptrace_list`**     | **调试链接指针**。如果本进程**被**另一个进程跟踪（调试），这两个指针用于将自己链接到调试器的 `ptrace_children`链表中。 |