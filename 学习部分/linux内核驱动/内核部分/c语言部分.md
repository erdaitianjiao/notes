### C语言

#### 关键字

##### volatile (编译优化阶段)

作用:告诉编译器该变量是容易发生变化的，不能对该变量进行优化，每次取值
都必须从内存中取值而不是直接去取之前在寄存器中的值

1. 多线程使用共享变量：因为多线程是多核操作，同时进行
2. 中断：中断程序会修改其他程序中使用的变量
3. 硬件寄存器：因为寄存器随时会被修改，好比 AD 转换的寄存器，随时会
   因 为电压变化而修改
4. 外部任务会修改变量

##### extern(链接阶段) 

该作用主要是告诉编译器我在其他文件定义了变量 a，并且分配了空间，不再为该变量申请空间

1. 声明外部变量：（保存在数据段）
2. 声明外部外部函数声明外部一样
3. Extern “C” 确保c++能正确调用c语言编写的函数

##### static
c 语言：变量、函数 C++：类中变量、类中静态成员函数

1. 静态全局变量  作用域只能作用域本文件，每次函数调用该变量都会被初始化

2. 静态局部变量 生命周期不会随函数结束结束，直到程序结束，但
   是在函数外面不能使用该变量，只能在函数中使用，该变量是有记忆的，会记住
   上次的值，该变量只被初始化一次

   **如果初始化的会在数据段内，未初始化的在.bss 段或者初始化为 0**

3. 静态函数  **静态函数只能在本源文件中使用**, 也就是说在其他源文件中可以定义和自己名字一样的函数

4. 定义类中的静态成员变量（不能在类里面初始化，不占类内存空间，必须定义才能使用）

##### sizeof(编译)

1. Sizeof()和 strlen()的区别
   首先 sizeof 是关键字，strlen 是函数，sizeof 用来计算占用内存大小，
   strlen 是用来计算字符串的长度，
   特别是对于需不需要包含\0 问题：
   Sizeof 是需要给\0 计算空间的，strlen 是不需要，
   sizeof 是在的时候计算的，而 strlen 是在运行的时候计算

~~~c
#define mysizeof(value) (char*)(&value + 1) - (char*)(&value);
~~~

##### struct 

将不同类型的数据组合在一起

1. **内存分布**

   - 结构体的内存分布由编译器决定，通常涉及 **对齐** 与 **补全（padding）**
   - **成员对齐规则**（以常见 GCC/MSVC 为例）：
     1. 每个成员的起始地址要对齐到其类型大小的整数倍位置
        - 比如 int（4字节）要放在4的倍数的地址上
     2. 整个结构体的大小必须是 **最大成员对齐数** 的整数倍（编译器可能会在末尾补齐）

2. **减少内存浪费的方法**

   1. **调整成员顺序**
       将占用空间小的、对齐要求低的成员集中在一起

      ```c
      struct Better {
          int b;   // 4 字节
          char a;  // 1 字节
          char c;  // 1 字节
      }; 
      ```

      - 实际大小为 8 字节，比 12 字节更紧凑

   2. **使用 #pragma pack(n)**（非标准，不同编译器行为不同）

      - 用于指定最大对齐数，减少补齐字节，但可能降低访问效率

   3. **使用**\__attribute__((packed))

      - **编译器不再为结构体成员进行自动补齐（padding）**，成员按照声明顺序紧凑排列

##### union联合体

1.  **union 的基本概念**
   - **联合体（union）** 是一种用户自定义的数据类型
   - 和 struct 类似，可以包含多个不同类型的成员
   - **区别**：所有成员 **共享同一段内存空间**，所以在同一时刻只能存储一个成员的值
2. **内存分布**
   - **struct**：每个成员都有独立的内存空间，整体大小 ≥ 各成员大小之和（考虑对齐补齐）
   - **union**：所有成员共享同一块内存，整体大小 = **最大成员的大小**（也受对齐规则影响）
3. **使用场景**
   - **struct**
     - 用来存放**多个字段的组合数据**，每个字段都可以同时使用
     - 例如：学生信息（姓名、学号、成绩）
   - **union**
     - 用来存放**不同类型但互斥的值**，节省内存
     - 常见于：
       - **协议解析**（同一片内存按不同方式解释）
       - **硬件寄存器映射**（按位字段和整体值切换访问）
       - **变长数据**（只用到其中一种类型）

##### register

定义

- register 是 C 语言的一种 **存储类说明符**（Storage Class Specifier）

- 它用于提示编译器：

  > **尽量把该变量存放在 CPU 寄存器中，而不是内存中，以提高访问速度**
  >
  > 不能取地址

~~~c
register int x = 0;
~~~

##### auto 

1. **定义**
   - auto 是 **存储类说明符**（Storage Class Specifier）
   - 用来声明 **自动存储期的局部变量**
   - **默认的存储类**：如果没有写，局部变量默认就是 auto
2. **特点**
   1. **存储位置**
      - 位于 **栈（stack）** 中
   2. **生命周期**
      - 从 **进入作用域** 时分配内存，
      - **离开作用域** 时释放
      - 例如在函数调用结束后，auto 变量会自动销毁
   3. **作用域**
      - 局部变量，**只能在定义它的代码块中使用**
   4. **初始化**
      - 不会自动初始化，必须 **手动赋值**，否则内容为随机值（未定义）

~~~c
auto int a = 10;
~~~

##### const

1.  const 用来修饰变量，表示该变量 **只读，不允许修改**

2. const 修饰函数参数 表示函数体内 **不能修改参数的值**

3.  const 修饰函数返回值 修饰返回值，表示调用者 **不能修改返回值内容**

4.  **const 与指针的组合**

   **const 靠近谁，就修饰谁**

   1. const int *p; 或 int const *p;
      - **指向的内容不可改**，指针本身可改
      -  “常量指针”
   2. int * const p;
      - **指针本身不可改**，内容可改
      -  “指针常量”
   3. const int * const p;
      - **指针和内容都不可改**

5. **const 与数组大小**

   - 在 **C 语言**中，const n 并不是真正的编译期常量，本质上仍然是变量 --> **数组大小必须是确定值**
   - 在 **C++** 中 const int n=3; 可以作为数组大小（C99 标准中也允许 **变长数组 VLA**，但并非所有编译器支持）所以在 C 语言中：

   - **数组大小、switch case 的常量** --> 推荐使用 #define 或 enum，不要用 const

6. **const 变量的存储位置**

   1. **局部 const 变量**
      - 存放在 **栈** 中，生命周期随函数结束而释放
      - 可以通过指针间接修改（只读性并非绝对）
   2. **全局 const 变量**
      - **已初始化**：存放在 **只读数据段（.rodata）**，通常不能通过指针修改
      - **未初始化**：存放在 **BSS 段**

##### typedef

1. **基本概念**
   - typedef 是 **C 语言关键字**，用于给已有类型 **起别名**
   - 本质：**编译阶段处理，有类型检查**，增强可读性
   - 不能在函数体内部使用（只能在作用域内声明类型别名）

##### #define

1. **基本概念**
   - #define 是 **预处理指令**，用于 **定义宏**
   - 宏在 **预处理阶段**被简单文本替换，不经过编译器的类型检查

##### #define vs typedef 

| 特性              | #define                                                      | typedef                                                      |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **类型**          | 预处理指令（宏）                                             | 关键字（类型别名）                                           |
| **处理阶段**      | **预处理阶段**                                               | **编译阶段**                                                 |
| **类型检查**      | 无类型检查                                                   | 有类型检查                                                   |
| **作用域**        | 从定义处到文件末尾，或遇到 #undef                            | 当前作用域内有效                                             |
| **功能**          | 文本替换、常量定义、表达式宏、条件编译                       | 给已有类型起别名（数组、指针、结构、函数指针）               |
| **安全性**        | 容易出错，如指针宏、运算顺序问题                             | 安全，符合类型规则                                           |
| **数组/指针差异** | 宏不会改变类型，例如 #define myptr int* p --> a 是指针，b 不是 | typedef 定义指针类型，例如 typedef int* myptr --> a、b 都是指针 |
| **使用建议**      | 定义常量、条件编译、简单宏                                   | 定义类型别名，提高可读性和可维护性                           |



##### C语言到可执行文件的过程

C 程序从源码到可执行文件分 4 步：预处理、编译、汇编、链接
 预处理负责宏展开和头文件处理；编译生成汇编代码；汇编生成目标文件；链接把目标文件和库文件结合，完成符号解析和地址重定位，最终得到可执行文件

- 有四个阶段
  1. **预处理（Preprocessing）**
  2. **编译（Compilation）**
  3. **汇编（Assembly）**
  4. **链接（Linking）**

1. **预处理阶段（Preprocessing）**

      工具：cpp（C PreProcessor）

   - 处理以 # 开头的预处理指令：
     - **宏替换**：#define PI 3.14--> 替换为具体值
     - **文件包含**：#include <stdio.h>--> 插入头文件内容
     - **条件编译**：#ifdef / #ifndef / #endif --> 控制代码是否编译
   - 删除注释（//、/* ... */）
   - 结果：生成一个 **纯净的 C 源代码文件**（扩展名通常为 .i）

2. **编译阶段（Compilation）**

   ​	工具：gcc 前端 / clang 前端

   - 主要任务：把预处理后的 .i 文件翻译成汇编语言 .s
   - 处理内容：
     - **词法分析**：把代码转成“单词”（token）
     - **语法分析**：检查语法是否正确，生成语法树
     - **语义分析**：检查类型是否匹配、变量是否声明
     - **优化**：常量折叠、死代码消除等
     - **生成汇编代码**：对应 CPU 指令集
   - 结果：得到 **汇编文件 .s**

3. **汇编阶段（Assembly）**

   ​	工具：as（汇编器）

   - 把 .s 文件转成 **机器指令（二进制）**，生成目标文件 .o
   - .o 文件的特点：
     - 是二进制文件，但 **还不能直接运行**
     - 内部通常包含 **符号表**（函数/变量名）、**重定位信息** 等
   - 结果：得到 **目标文件 .o**

4. **链接阶段（Linking）**

   ​	工具：ld（链接器）

   - 把多个目标文件 .o 和库文件 .a / .so 结合，生成最终的可执行文件
   - 主要任务：
     - **符号解析**：解决函数/变量的引用与定义
       - 比如 printf() 在 main.c 中调用，但它定义在 libc.so 中，链接器负责找到它
     - **地址重定位**：把函数、变量的相对地址换成最终的绝对地址
     - **合并段**：把各个 .o 文件的 .text（代码段）、.data（已初始化数据）、.bss（未初始化数据）等合并
   - 结果：得到 **可执行文件（ELF、PE 等格式）**，如 a.out 或 main.exe

#### GUN拓语法

##### \__attribute__ 

1. 定义

   - \__attribute__((...)) 是 GCC 提供的 **给变量、函数或类型添加属性的语法**
   - 作用：改变编译器的默认行为或优化方式

2. 常见属性

   | 属性                     | 用法 & 示例                                                  | 作用                         |
   | ------------------------ | ------------------------------------------------------------ | ---------------------------- |
   | packed                   | struct S { char a; int b; } \__attribute__((packed));        | 取消结构体内存补齐           |
   | aligned(n)               | int x \__attribute__((aligned(16)));                         | 指定变量/结构体对齐到 n 字节 |
   | unused                   | int temp \__attribute__((unused));                           | 避免未使用变量的警告         |
   | deprecated               | void old_func() \__attribute__((deprecated));                | 标记函数过时，调用时发警告   |
   | noreturn                 | void panic() \__attribute__((noreturn));                     | 表示函数不返回               |
   | format(printf, m, n)     | void myprintf(const char *fmt, ...) \__attribute__((format(printf, 1, 2))); | 检查格式化字符串参数是否匹配 |
   | constructor / destructor | void init() \__attribute__((constructor));                   | 程序开始前/结束后自动执行    |
   | weak                     | int foo() \__attribute__((weak));                            | 定义弱符号，可被覆盖         |
   | visibility("hidden")     | int var \__attribute__((visibility("hidden")));              | 控制符号可见性               |
   | alias("other_func")      | void old() \__attribute__((alias("new")));                   | 函数别名                     |



##### typeof（类型推导）

- typeof(expr) 返回表达式的类型
- 常用于宏或泛型编程中

```c
int a = 5;
typeof(a) b = 10;  // b 的类型同 a
```

##### inline 与 always_inline

- inline：建议函数内联（C99 标准已支持）
  - inline 用于 **建议编译器将函数进行内联展开**，即**在调用处直接插入函数代码**，避免函数调用的开销（如压栈、跳转）
- \__attribute__((always_inline))：强制内联（GCC 扩展）
- 特点
  1. **减少函数调用开销**
     - 对小函数、频繁调用函数效果明显
     - 避免函数压栈、返回、跳转，提高效率
  2. **影响链接**
     - 如果函数定义在头文件中，使用 `inline` 可以防止多重定义错误（配合 `static inline` 最常用）
  3. **不改变语义**
     - 内联只是优化，**逻辑行为与普通函数相同**
  4. **现代编译器优化**
     - 编译器可能自动内联，不一定依赖 `inline`
     - `inline` 更多是提示编译器优化意图

```C
inline int add(int x, int y) { return x + y; }
int add2(int x, int y) \__attribute__((always_inline));
```

##### \__extension__

- 用于 **关闭编译器的标准警告**，允许使用 GNU C 扩展语法

```C
__extension__ long long big_num = 10000000000LL;
```

##### \__builtin__ 系列

- GCC 提供的内置函数，用于直接调用 CPU 指令或优化操作
- 例如：

```C
int clz = __builtin_clz(16); // 计算前导零
int popcount = __builtin_popcount(15); // 计算二进制中1的个数
```

##### 总结

1. **GCC 扩展语法** = 提高灵活性和优化能力，但非标准 C
2. **常用场景**：
   - 内存布局控制 (`packed` / `aligned`)
   - 编译优化 (`always_inline` / `noreturn`)
   - 宏和泛型 (`typeof`)
   - 符号控制 (`weak` / `alias` / `visibility`)
3. **注意**：
   - 便于嵌入式、系统编程或底层优化
   - 可移植性差，不适合跨编译器项目



#### ELF文件格式

~~~pgsql
+-----------------------------+
| ELF Header                  | <- 文件头，描述文件类型、入口地址等
+-----------------------------+
| Program Header Table (PHT)  | <- 段表，描述程序加载到内存的各个段
+-----------------------------+
| Sections                    | <- 节区（Sections），包含代码、数据等
|   .text                     | <- 代码段，存放程序指令
|   .rodata                   | <- 只读数据段，存放常量字符串、const变量
|   .data                     | <- 已初始化全局/静态变量
|   .bss                      | <- 未初始化全局/静态变量（加载时置零）
|   .stack                    | <- 栈（运行时才存在）
|   .heap                     | <- 堆（运行时才存在）
+-----------------------------+
| Symbol Table / Relocations   | <- 符号表、重定位信息
+-----------------------------+
| Section Header Table (SHT)  | <- 节表，描述各节的偏移、大小、属性
+-----------------------------+

~~~
