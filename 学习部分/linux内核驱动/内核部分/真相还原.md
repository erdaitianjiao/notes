### 真相还原

#### 内存地址基本概念

- **物理地址**：内存真正的地址，具有唯一性，是CPU访问内存的最终地址
- **有效地址（逻辑地址）**：段内偏移地址，程序员可见的地址，需与段基址结合使用
- **线性地址/虚拟地址**：非真实内存地址，用于描述程序地址空间在分页机制下，线性地址即虚拟地址

#### 地址转化

-  实模式下的地址转换
  1. 输入：段基址（默认在段寄存器中）+ 段内偏移地址
  2. 处理：段基址 × 16 + 段内偏移地址
  3. 输出：直接作为物理地址访问内存
  
-  保护模式下的地址转换
  1. 段基址通过选择子在GDT中查找段描述符获得
  2. 段基址 + 段内偏移地址 = 线性地址
  3. 地址转换分支：
     - 未开启分页：线性地址直接作为物理地址
     - 开启分页：线性地址（虚拟地址）需经页部件转换为物理地址
     - 分页转换过程：通过查找页表将虚拟地址映射为物理地址

#### CPU实模式和保护模式

- **实模式**

  1. 20位地址总线，最大可访问1MB

  2. 段寄存器仅高16位有效

  3. **物理地址 = 段寄存器值 × 16 + 偏移地址**
- **保护模式**
  1.  **分段+可选分页**：通过**全局描述符表(GDT)** 或局部描述符表(LDT)获取段基址，再与偏移地址合成线性地址，最后由MMU分页单元转换为物理地址
  2.  32位地址线（80386+），最大**4GB物理内存**（64位模式更大）
  3.  内存保护，通过**特权级（0-3环）** 和段描述符中的权限位进行严格检查，防止未授权访问
- **从实模式进入保护模式**
  1.  **加载全局描述符表(GDT)**
  2.  **打开A20地址线**
  3.  **将CR0寄存器的PE置1位(第0位)**

#### 分页机制

- 基础概念

  | **组件**               | **定义**                                     | **主要作用**                 | **关键特点**                                    |
  | :--------------------- | :------------------------------------------- | :--------------------------- | :---------------------------------------------- |
  | 页（Page）             | 进程虚拟地址空间中的固定大小块               | 虚拟内存分配和管理的基本单位 | 大小固定（如4KB），独立于物理内存布局           |
  | 页框（Page Frame）     | 物理内存中的固定大小块                       | 存放页的物理载体             | 与页大小相同，由硬件物理地址标识                |
  | 页表（Page Table）     | 存储虚拟页号（VPN）到物理页框号（PPN）的映射 | 实现虚拟地址到物理地址的转换 | 每个进程独立拥有，支持内存隔离                  |
  | 页表项（PTE）          | 页表中的条目                                 | 记录映射关系及控制信息       | 包含存在位（P）、权限位（R/W/U/S）、脏位（D）等 |
  | MMU（内存管理单元）    | CPU中的硬件单元                              | 执行虚拟地址到物理地址的转换 | 集成TLB，支持多级页表和权限检查                 |
  | TLB（快表）            | MMU中的高速缓存                              | 缓存近期使用的页表项         | 访问速度接近CPU主频，命中率直接影响性能         |
  | 多级页表               | 层次化页表结构（如4级页表）                  | 减少页表内存占用             | 按需创建页表，仅映射实际使用的地址空间          |
  | 缺页异常（Page Fault） | 访问不在物理内存的页时触发的异常             | 实现虚拟内存的核心机制       | 操作系统介入页面调度，可能触发页面置换          |

- 在分页机制出现前，内存管理依赖**连续分配的分段机制**，存在两大核心问题
  1. **外部碎片**
  2. **内存利用率低**
- 工作原理
  - **虚拟地址** = 虚拟页号（VPN） + 页内偏移量（Offset）
  - **物理地址** = 物理页框号（PPN） + 页内偏移量（Offset）
  - **偏移量长度**：由页面大小决定，如4KB页对应12位偏移量（2^12=4096）
- 缺页异常
  1. **异常触发**：MMU检测到PTE存在位为0
  2. **合法性检查**：OS验证虚拟地址是否在进程地址空间内
  3. **内存分配**：查找空闲页框，若内存不足则执行页面置换（如LRU算法）
  4. **页面调入**：将目标页从磁盘交换区读入内存，更新PTE的PPN和存在位
  5. **重试指令**：返回到触发异常的指令，重新执行地址转换

#### 特权机制

- 等级划分

  - **Ring 0**：最高特权，操作系统内核所在层级，能直接控制硬件和所有核心数据
  - **Ring 3**：最低特权，用户应用程序所在层级，权力最弱
  - Ring 1 & 2：中间特权，通常为驱动程序或系统服务保留

- **TSS（Task State Segment，任务状态段）**

  - **任务切换**：存储任务上下文（寄存器状态、栈指针等）
  - **特权级切换**：提供不同特权级的栈指针（SS0:ESP0 ~ SS3:ESP3）
  - **硬件支持**：通过任务门（Task Gate）或`IRET`指令触发任务切换

  | 概念    | 全称                       | 存储位置        | 作用描述                                                     |
  | :------ | :------------------------- | :-------------- | :----------------------------------------------------------- |
  | **CPL** | Current Privilege Level    | CS寄存器最低2位 | 当前执行代码的特权级（0级内核最高，3级用户最低）             |
  | **DPL** | Descriptor Privilege Level | 段描述符位5-6   | 段/门的特权级要求，访问需满足`CPL ≤ DPL`且`RPL ≤ DPL`        |
  | **RPL** | Requested Privilege Level  | 段选择子最低2位 | 请求者的特权级，限制低特权程序访问高特权段（即使CPL满足要求） |

#### 内存管理

基于**分页机制**和**位图管理**的物理/虚拟内存管理器，支持内核和用户空间的内存分配与释放

1. **双池分离**：内核与用户内存池隔离，提高安全性和稳定性
2. **大小内存分离处理**：
   - 大内存（>1024B）直接按页分配
   - 小内存使用对象池+空闲链表，减少碎片
3. **位图管理**：高效且节省内存（1位管理4KB）
4. **自映射页表**：通过固定虚拟地址访问页目录和页表
5. **原子操作**：通过中断开关/锁保证位图操作的原子性
6. **懒清除**：页表释放时只置P位为0，实际页框未清零（下次分配时由memset清0）

**具体内容**

- 数据结构 **位图bitmap** 一个bit表示是否一块内存是否被占用 使用**互斥锁lock** 保证并发安全

- 物理内存池

  **创建了两个物理内存池 用户内存池和内核用户池** 

  ~~~c
  // 内存池结构 生成两个示例用于管理内核内存池和用户内存池
  struct pool {
  
      struct bitmap pool_bitmap;                  // 本内存池用到的位图结构 用于管理物理内存
      uint32_t phy_addr_start;                    // 本内存池所管理的物理内存起始地址
      uint32_t pool_size;                         // 本内存池字节容量
      struct lock lock;                           // 申请内存时互斥
  
  };
  ~~~

  

- 虚拟内存池 

  ~~~c
  // 虚拟内存池 用于虚拟地址管理
  struct virtual_addr {
  
      struct bitmap vaddr_bitmap;         // 虚拟地址用到的位图结构
      uint32_t vaddr_start;               // 虚拟地址的起始位置
  
  };
  ~~~

- **小内存块管理（≤1024字节）**

  ~~~c
  // 内存块
  struct mem_block {
  
      struct list_elem free_elem;
  
  };
  
  struct mem_block_desc {
  
      uint32_t block_size;                // 内存块大小
      uint32_t blocks_per_arena;          // 本arena中可容纳此mem_block的数量
      struct list free_list;              // 目前可用的mem_block链表
  
  };
  
  // 内存仓库
  struct arena {
  
      struct mem_block_desc* desc;                // 此arena关联的mem_block_desc
      // large 为ture的时候 cnt表示的页框数
      // 否则表示的是空闲mem_block数量
      uint32_t cnt;
      bool large;
  
  };
  ~~~

  

#### 线程管理

-  **核心设计思想**

1. 统一管理：将线程和进程统一为（PCB）进行管理线程共享地址空间（pgdir = NULL），进程拥有独立地址空间（pgdir指向独立页表）
2. 调度算法：采用基于**优先级的时间片轮转**（Round-Robin） 算法
   - 优先级越高，分配的 ticks（时间片）越长
   - 时间片用完后，线程被放入就绪队列尾部，保证公平性
3. 两级栈结构：每个线程拥有两个栈，用于不同场景：
   - 中断栈 (intr_stack)：位于内核栈顶端，固定位置用于中断发生时由硬件/汇编自动压入，保存所有寄存器上下文
   - 线程栈 (thread_stack)：位置不固定用于主动调度时保存部分上下文，并存储线程首次执行的引导信息（函数地址、参数）

- 核心运作流程

 	1. 线程创建 (thread_start)
 	 - 流程：申请PCB内存 -> init_thread初始化PCB -> thread_create初始化内核栈 -> 加入就绪队列和全部队列
 	 - **线程栈初始化**：设置 eip指向 kernel_thread函数，并存入目标 function和 func_arg
 	
 	2. 调度器 (`schedule`)
 	   - 时机：由时钟中断或线程主动调用（如`block`, `yield`）
 	   - **流程**：
 	     1. 将当前线程（若因时间片用完）重新加入**就绪队列尾**
 	     2. 若就绪队列空，则唤醒 `idle`线程
 	     3. 从**就绪队列头**取出下一个线程 `next`
 	     4. 调用 process_activate(next)切换页表（若`next`是进程）
 	     5. 调用 switch_to(cur, next)**切换上下文**

3. 上下文切换 (`switch_to`汇编)
   - 核心动作**：**切换内核栈指针 `esp`
     1. 保存现场：将当前线程（`cur`）的寄存器（esi, edi, ebx, ebp）压入*其自己的*内核栈
     2. 保存栈顶：将当前 `esp`保存到 `cur->self_kstack`
     3. 恢复栈顶：将 `next->self_kstack`加载到 `esp`寄存器（至此，CPU已在执行`next`线程的上下文）
     4. 恢复现场：从新栈中弹出 `next`线程的寄存器
     5. `ret`指令返回：跳转到 `next`线程被打断的位置继续执行

4.  线程生命周期控制
   - thread_block(): 主动阻塞自己，并触发调度
   - thread_unblock(): 唤醒被阻塞线程，将其加入**就绪队列头**（优先调度）
   - thread_yield(): 主动让出CPU，将自己加入**就绪队列尾**

- 初始化流程 (thread_init)

1. 初始化队列和锁
2. 创建第一个用户进程 init(PID=1)
3. 将当前 `main`函数封装为主线程
4. 创建 `idle`空闲线程（CPU无任务时执行 `hlt`指令节能）

- **PCB结构**

~~~c
// 中断栈 intr_stack
// 此结构用于发生中断时保护程序(进程或线程)的上下文结构
// 进程或者线程被外部中断打断时 会按照以下结构压入上下文
// 寄存器 intr_exit 中的出栈操作是此结构体的逆操作
// 此栈在线程自己的内核栈中位置固定 所在页的最顶端
struct intr_stack {

    uint32_t vec_no;            // kernel.S 宏VECTOR中push %1压入的中断号
    uint32_t edi;
    uint32_t esi;
    uint32_t ebp;
    uint32_t esp_dummy;         // 虽然pushad把esp也压入 但esp是不断变化的 所以会被popad忽略
    uint32_t ebx;
    uint32_t edx;
    uint32_t ecx;
    uint32_t eax;
    uint32_t gs;
    uint32_t fs;
    uint32_t es;
    uint32_t ds;

    // 以下是cpu从低特权进入高特权时压入的
    uint32_t err_code;
    void (*eip)(void);
    uint32_t cs;
    uint32_t eflags;
    void* esp;
    uint32_t ss;

};

// 线程栈 thread_task
// 线程自己的栈 用于存储线程中待执行的函数
// 仅用在switch_to时保存线程环境
// 实际位置取决于实际运行情况
struct thread_stack {

    uint32_t ebp;
    uint32_t ebx;
    uint32_t edi;
    uint32_t esi;


    // 线程第一次执行时 eip指向待调用的函数kernel_thread
    // 其他时候 eip是指向switch_to的返回值的
    void (*eip)(thread_func* func, void* func_arg);

    // 以下用于第一次被调度上cpu使用
    // 参数unused_ret只为占位置充数为返回地址
    void (*unused_retaddr);             
    thread_func* function;              // 由kernel_thread所调用的函数名
    void* func_arg;                     // 由kernel_thread所调用的函数所需要的参数

};

// 进程或线程的pcb 程序控制块
struct task_struct {

    uint32_t* self_kstack;              // 各内核线程都用自己的内核栈
    pid_t pid;
    enum task_status status;
    uint8_t priority;                   // 线程优先级
    char name[16];
    uint8_t ticks;                      // 每次在处理器上执行的时间滴答数
    
    // 此任务自上cpu运行至今占用了多少cpu滴答数 也就是执行了多久
    uint32_t elapsed_ticks;
    
    // genenal_tag的作用是与线程在一般队列中的节点
    int32_t fd_table[MAX_FILES_OPEN_PER_PROC]; 

    // general_tag的作用是用于在线程在一般队列中的节点
    struct list_elem general_tag;

    // all_list_tag作用是用于线程队列thread_all_list中的节点
    struct list_elem all_list_tag;

    uint32_t* pgdir;                    // 进程自己页表的虚拟地址
    struct virtual_addr userprog_vaddr; // 用户进程的虚拟地址
    struct mem_block_desc u_block_desc[DESC_CNT];
    uint32_t cwd_inode_nr;              // 进程所在的工作目录的inode编号
    int16_t parent_pid;                 // 父进程pid
    uint32_t stack_magic;               // 栈的边界标记 用于检测栈溢出

};
~~~



#### 中断调用

- 中断描述表

  - IDT（Interrupt Descriptor Table）是 CPU 用于处理中断和异常的核心数据结构，每个表项称为中断门描述符（gate descriptor）

  - 表项包含：处理函数的地址（低 16 位 + 高 16 位）、代码段选择子、DPL（特权级）、属性字段等

  - 内核通过 `make_idt_desc` 建立各个表项，并使用 `lidt` 将 IDT 加载到 CPU

  - 普通中断入口（如时钟、键盘）使用 **内核态特权级（DPL=0）**，而系统调用入口（int 0x80）单独配置为 **用户态可访问（DPL=3）**，保证用户程序能通过中断指令安全进入内核

-  中断入口与上下文保存机制

  - 每个中断向量对应一个入口函数，在 `kernel.S` 中通过 `VECTOR` 宏自动生成

  - 入口处理过程：
    1. 保存现场：依次压入段寄存器（ds/es/fs/gs）和通用寄存器（pushad）；
    2. 发送 EOI（End of Interrupt）信号给 8259A PIC，允许下一次中断到来；
    3. 将中断向量号压栈，并调用 `idt_table[vec_no]` 中注册的 C 语言处理函数；调用完成后，通过 `intr_exit` 恢复寄存器与栈，执行 `iretd` 返回

  这种机制保证了：

  - **汇编层负责上下文保存与恢复**，保证中断处理的原子性；
  - **C 层负责具体逻辑**（如调度、异常处理），实现模块化设计

- 系统调用（int 0x80）

  - 使用 `0x80` 号中断作为系统调用入口，允许用户态安全进入内核

  - 系统调用流程：
    1. 用户程序执行 `int 0x80` 指令触发软中断；
    2. 汇编入口保存上下文，并将系统调用号（存于 `eax`）和参数（存于 `ebx/ecx/edx`）传递给内核；
    3. 内核通过 `syscall_table` 查找对应服务函数并调用；
    4. 函数返回值写回 `eax`，在 `intr_exit` 恢复现场后返回用户态

  - 该机制保证了 **用户态 -> 内核态** 的受控切换，是进程与内核交互的标准接口



#### 文件管理部分

- 构成

  1. SuperBlock 超级块 存储文件系统元数据的核心结构
  2. inode 存储文件元数据和数据块指针
  3. 目录系统
     - **目录项结构：** 文件名（16字符）+ inode编号 + 文件类型
     - **目录操作：** 目录遍历 目录创建/删除
  4. 文件操作
     - 创建/打开/关闭
     - 读写
     - 删除
- 实现思路 
  
  1. 空间管理机制
  
     - 位图分配：
       1. 块位图：跟踪数据块分配状态
       2. inode位图：跟踪inode分配状态
     - 分配策略：首次适应算法，`bitmap_scan`查找空闲位
     - 同步机制：每次分配/释放后通过`bitmap_sync`同步到磁盘
  2. 数据组织形式
  
     - 混合索引：
  
       1. 直接块：12个，适合小文件
  
       2. 一级间接块：128个，扩展到大文件
     - 目录项存储：
       1. 固定大小（24字节），不跨扇区存储
       2. 每个扇区可存储21个目录项（512/24）
  3. 目录遍历与路径解析
     - 路径解析：`path_parse`递归拆分路径分量
     - 文件查找：`search_file`逐层查找目录项，返回inode和父目录
     - 当前工作目录：进程级`cwd_inode_nr`，支持相对路径访问
  4. 并发控制与缓存
     - 写互斥：`write_deny`标志确保同一文件不会被并发写入
     - inode缓存：`open_inodes`链表缓存已打开inode，减少磁盘I/O
     - 目录项缓存：`dir_buf`缓存当前扇区目录项，加速遍历
  









