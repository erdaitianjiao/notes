### linu0.11内核

#### 一、boot 部分

##### 文件

  ~~~
  boot
  ├── Makefile
  ├── bootsect.s
  ├── head.s
  └── setup.s
  ~~~

##### 启动流程

  1. 自我搬移bootsect.s

     - bootsect.s 首先将自己从 **0x7C00** 移动到 **0x90000**（576KB），以便腾出低端内存区域供后续使用

  2. 加载 setup.s

     - 接着，它会将启动设备中 **2KB 的 setup.s** 读入到 **0x90200** 处
     - setup.s 也是一个运行在实模式下的汇编程序，用来进一步准备系统环境‘

  3. 加载内核主体（system 模块）

     - bootsect.s 还会把 **system 模块（内核主体部分）** 装载到内存的 **0x10000** 处
     - 由于 system 模块大小不会超过 **0x80000 字节（512KB）**，所以不会覆盖位于 **0x90000** 开始的 bootsect 和 setup

  4. 内核搬移

     - 后续由 setup.s 将 system 模块移动到 **内存起始地址（0x00000）**
     - 这样，system 模块中的逻辑地址与实际物理地址一致，方便内核在保护模式下对代码和数据进行直接操作

     

  ![boot文件移动方式](.\img\boot文件移动方式.png)

##### 功能总结

  在 **bootsect.s** 完成初始加载后，启动流程进入 **setup.s** 和 **head.s** 阶段

  1. 执行权交接

     bootsect.s 将自身和 **setup.s** 分别移动到 **0x90000** 和 **0x90200** 处；

     同时将 **system 模块**加载到内存 **0x10000** 开始的位置；

     随后把控制权交给 **setup.s**

     system 模块的开头部分就是 **head.s**

  2. setup.s 的主要任务

     **收集硬件参数**：调用 ROM BIOS 中断，获取机器的基本配置信息（显示卡、内存大小、硬盘参数等），并将这些信息保存到 **0x90000** 起始的内存区域，供内核后续使用

     **搬移内核主体**：将 system 模块整体下移到 **0x00000**，使其逻辑地址与物理地址一致此时，**head.s** 正好位于内存起始地址 **0x00000**

     **建立保护模式环境**：

     - 加载 **GDT（全局描述符表）基地址**到 GDTR，
     - 重新初始化中断控制器，
     - 设置 **CR0 控制寄存器**，
     - 最后跳转到 system 模块的 **head.s** 入口，使 CPU 进入 **32 位保护模式**

  3. head.s 的主要任务

     - **初始化 IDT**：设置中断描述符表（IDT）的 256 项，保证保护模式下的中断响应机制可用
     - **检查 CPU 硬件环境**：
       - 测试 **A20 地址线** 是否开启（以突破 1MB 内存寻址限制），
       - 检查系统是否存在 **数学协处理器（80287/80387）**
     - **初始化分页机制**：建立 **页目录表**和相关页表，准备启用分页内存管理
     - **跳转到 init/main.c**：完成汇编级初始化后，进入 system 模块中的 C 语言初始化程序 **init/main.c**，继续更高层次的系统初始化（如进程调度、文件系统等）

##### 总结

  过程 bootsect.s -->setup.s -->head.s -->init/main.c



#### init 部分

##### 文件

  只有一个mian.c文件，负责 **整个内核初始化工作**：内存划分、硬件初始化、进程 0/1 的创建等

- 运行流程

  ![mian函数流程](.\img\initmian函数运行.png)

##### 功能

  1. **内存管理初始化**

     - **利用 setup.s 提供的硬件参数**：
       - 设置根文件系统设备号；
       - 设定内存全局变量（主内存起始地址、内存总容量、高速缓冲区末端地址）；
       - 如果启用了虚拟盘（RAMDISK），主内存会相应减少
     - **内存分区示意**（参考图 4-1）：
       - **内核程序区**
       - **高速缓冲区**（1KB/块，用于磁盘等块设备 I/O，需扣除显存和 BIOS 占用部分）
       - **虚拟盘（若定义）**
       - **主内存区**（由 mm 模块管理，以 4KB 页为单位进行分页分配）
  
  2. **硬件与子系统初始化**
  
     内核调用一系列函数，完成：
  
     - **中断与异常**：陷阱门、IDT 初始化；
     - **设备驱动**：块设备、字符设备、TTY；
     - **进程管理**：创建内核第一个任务（task 0）
     
     

  完成所有初始化后，设置中断允许标志，系统正式可响应中断

  3. **进程 0（任务 0）**
  
     - main() 切换到 **进程 0** 运行，CPU 从特权级 0 切换到特权级 3（进入用户模式）
     - **进程 0 的职责**：
       - 使用 `fork()` 创建第一个子进程（进程 1，即 init 进程）；
       - 本身成为系统的 **idle 进程**（空闲时只执行 `pause()`，并在需要时调用调度程序）
     - **特殊要求**：
       - 在创建 init 之前，进程 0 不能使用用户态堆栈，因此 `fork()` 必须通过 **GCC 内联函数**实现，而不能用普通函数调用；
       - `pause()` 也必须使用宏或内联定义，避免在调度次序不确定时出现问题
  
  4. **进程 1（init 进程）**
  
     - 由进程 0 调用 `fork()` 创建
     - 负责完成用户态初始化工作：
       - 加载根文件系统；
       - 设置标准输入输出；
       - 执行 `/bin/sh`（shell）
     - **shell 子进程（进程 2 及以后）**：
       - 如果 shell 进程退出，父进程（init）会进入循环，不断重新生成新的 shell 进程
       - 这保证了系统始终提供一个可用的 shell 环境

##### 补充

###### fork() 系统调用原理

1.  **fork() 的作用**

   - **功能**：复制当前进程，生成一个新的进程
   - **父进程**：调用 fork() 的进程
   - **子进程**：新创建的进程

   fork() 会在 **进程表** 中为子进程建立一个新的表项，子进程与父进程几乎完全相同：

   - 拥有相同的代码；
   - 拥有独立的数据空间和环境参数；
   - 从调用 fork() 的位置继续执行

2.  **fork() 的返回值机制**

   fork() 的关键在于返回值不同：

   - **父进程中**：返回子进程的 **PID**（正整数）；
   - **子进程中**：返回 **0**；
   - **出错时**：返回小于 **0**

   > 这种设计使得同一份代码在 fork() 之后能“分岔”为两个执行流，父子进程根据返回值来执行不同的代码

![fork系统调用](.\img\fork系统调用.png)

#### 二、内存管理部分

##### 文件

~~~tree
mm
├── Makefile
├── memory.c
└── page.s
~~~

##### 基本内容

1.  **内存管理的基本功能**

   - **地址映射**：将程序使用的虚拟地址转换为物理地址
   - **内存保护**：防止越界访问，保证进程之间互不干扰

   > Linux 0.11 主要讲解 **分页机制**，段保护机制不做深入讨论

2. **地址转换流程**

   在 Intel 80386 架构下，地址的转换分两步：

   1. **段机制**：虚拟地址 = 段基址 + 偏移量 -->形成 32 位线性地址
   2. **分页机制**：线性地址通过 **页目录表 + 页表** 转换为物理地址

   - **线性地址结构**（32 位）：
     - 位 31–22 -->页目录索引（10 位）
     - 位 21–12 -->页表索引（10 位）
     - 位 11–0  -->页内偏移（12 位）
   - 每一级表占一页内存（4KB，1024 项，每项 4 字节）
   - 一个页目录最大寻址空间：`1024 × 1024 × 4KB = 4GB`

   ![页目录和页表结构示意图](.\img\页目录和页表结构示意图.png)

   ![线性地址变换示意图](.\img\线性地址变换示意图.png)

3. **页表与页目录项结构**

   每个表项占 4 字节，主要字段：

   - **页框地址 (20 位)**：物理页基址
   - **存在位 P**：是否有效，P=0 会触发缺页异常
   - **访问位 A、修改位 D**：由硬件设置，供内存换页算法使用
   - **读/写位 R/W、特权位 U/S**：用于分页级保护

   ![页框描述符结构](.\img\页框描述符结构.png)

4. **Linux 0.11 的内存使用情况**

   - **物理内存最大支持 16MB**
   - 内存分布：
     - 0–640KB：常规内存（内核 + 数据）
     - 640KB–1MB：显存和 BIOS ROM
     - 1MB–4MB：缓冲区（部分可能被显存/BIOS 占用）
     - 4MB–16MB：主内存区（用于进程和页表分配）
     
     ![主内存区域示意图](.\img\主内存区域示意图.png)
   - **head.s** 中初始化：
     
     - 在物理地址 0 创建页目录表
     - 随后建立 4 个页表，供任务 0 使用
     - 其它进程的页表在主内存区动态申请

5. **页异常与处理机制**

   分页机制下，如果访问无效或写保护页面，会触发 **14 号中断（page fault）**，由 `page.s` 处理：

   - **do_no_page()**：缺页异常 -->从磁盘读入所需页面
   - **do_wp_page()**：写保护异常 -->执行写时复制（COW）

6. **写时复制（Copy on Write, COW）**

   - **fork() 创建子进程**时，子进程共享父进程的物理页面，且全部标记为只读
   - 当父子进程之一尝试写入时：
     1. 触发写保护异常 (page fault)
     2. `do_wp_page()` 分配新物理页，将旧页内容复制过去
     3. 修改该页的权限为可写
     4. 返回后重新执行原指令
   - **优势**：加速进程创建，节省物理内存，直到有实际写操作才分配新页
   - **内核写入进程空间时**，会主动调用 `write_verify()` 检查共享页，必要时提前执行 COW

7.  **线性地址空间的使用**

   每个进程占用 64MB 的线性地址空间：

   - 起始地址 = 进程号 × 64MB
   - 结构：代码段、数据段、堆栈段、环境参数区（末尾 128KB）
   - 进程创建时，bss 段第一页初始化为 0
   
   ![进程在线性空间地址分布图](.\img\进程在线性空间地址分布图.png)

##### 内存分页管理（memory.c）

1.  **物理内存页的状态管理**

   内核通过 **字节数组 `mem_map[]`** 来记录主内存区每一页的使用情况：

   - 每个字节对应一个物理页
   - 数值 = 该页的占用计数（0 表示空闲）
   - 页的分配与回收通过 **计数加减**来实现

   **相关函数**

   - **`get_free_page()`**
     - 扫描 `mem_map[]`，找到空闲页（值为 0），置为 1
     - 清零该物理页内容
     - 返回物理页起始地址
     - 若无空闲页，返回 0
   - **`free_page(addr)`**
     - 判断地址是否有效：
       - `<1M`（内核专用） -->忽略
       - 超过物理内存上限 -->报错
     - 计算页号 `(addr - 1M)/4K`，将 `mem_map[page]` 减 1
     - 如果已经为 0，则报错 **“试图释放一空闲页面”**

2. **页目录与页表管理**

   物理页的分配回收只是底层资源管理，真正的 **进程虚拟地址空间** 还需要通过 **页目录表和页表** 来建立映射

   **相关函数**

   - **`free_page_tables(base_addr, size)`**
     - 按 **页表为单位 (4MB)** 释放线性地址空间
     - 检查地址是否对齐在 4MB 边界，否则报错并死机
     - 检查是否释放内核空间（0 起始地址），若是则死机
     - 从页目录项开始，逐个释放 `size` 个页目录项及对应页表项
     - 释放实际占用的物理页，并刷新 TLB
   - **`copy_page_tables(from, to, size)`**
     - 按 **页表为单位 (4MB)** 复制虚拟空间映射，用于进程创建时共享内存
     - 检查源、目的地址是否在 4MB 边界上
     - 复制页目录项、页表项，新页表需要分配物理页
     - 设置复制后的页面为 **只读**，依赖 **写时复制 (COW)**
     - 更新 `mem_map[]`，共享的物理页计数加 1
   - **`put_page(page, address)`**
     - 将指定的物理页映射到线性地址
     - 检查页地址是否在合法范围（>1MB 且 < 内存上限）
     - 定位线性地址对应的页目录项
       - 如果无效，分配一个新的页表存放映射
     - 更新页表项，建立物理地址映射
   - **`get_empty_page(address)`**
     - 封装函数：先调用 `get_free_page()` 分配物理页，再用 `put_page()` 映射到指定线性地址

3. **缺页与写保护处理**

   内存访问异常由 CPU **14 号中断 (Page Fault)** 触发，Linux 0.11 的异常处理在 `mm/page.s` 中实现，最终调用以下 C 函数：

   **相关函数**

   - **`do_wp_page()`**（写保护异常处理）
     - 如果异常地址在代码段 -->进程直接终止（代码不可修改）
     - 否则执行 **写时复制**：
       1. 分配新页
       2. 将旧页内容复制过去
       3. 更新页表项为可写
       4. 修改 `mem_map[]` 计数
   - **`do_no_page()`**（缺页异常处理）
     - 判断线性地址是否在进程代码 + 数据段范围内
     - 如果超出 -->新分配一页并映射（bss 或堆增长）
     - 如果在范围内 →
       1. 尝试页面共享（多个进程共用代码页）
       2. 如果失败 -->分配新页并从磁盘读入数据
       3. 若页面超过代码/数据长度，多余部分清零
     - 最终将页面映射到线性地址

- 总结

  Linux 0.11 的 **memory.c** 是整个内存管理的核心：

  1. **物理页分配与回收**：`get_free_page()` / `free_page()`
  2. **页表级操作**：`free_page_tables()` / `copy_page_tables()` / `put_page()`
  3. **异常处理**：`do_wp_page()`（写时复制）、`do_no_page()`（缺页加载）

  这一套机制实现了：

  - 动态内存管理（避免浪费）
  - 进程间的地址隔离
  - 写时复制（高效的 fork/进程创建）
  - 缺页加载（延迟分配，减少开销）

##### 页异常中断（中断 14）

**1. 触发条件**

页异常中断主要有两类情况：

1. **缺页 (Page Not Present)**
   - 访问的虚拟地址在页表中不存在（P=0）
   - 常见于 **延迟分配、按需调页**
   - 由 **`do_no_page(error_code, address)`** 处理
2. **写保护 (Write Protection)**
   - 页表项存在（P=1），但页面被标记为只读（R/W=0），进程却执行写操作
   - 常见于 **写时复制 (Copy on Write)**
   - 由 **`do_wp_page(error_code, address)`** 处理

**2. 出错信息**

当 CPU 发生页异常时，会自动保存关键信息：

- **error_code**（错误码）：由 CPU 压入栈中，表示异常原因
   主要位：
  - **P 位 (bit 0)**：0=缺页异常，1=写保护异常
  - **W/R 位 (bit 1)**：0=读异常，1=写异常
  - **U/S 位 (bit 2)**：0=内核态，1=用户态
- **CR2 寄存器**：由 CPU 自动写入，保存导致异常的 **线性地址**
  - 内核通过读取 CR2，知道哪个地址访问出错

**3. 中断处理流程**

1. CPU 检测到页访问异常 -->触发中断 14
2. 将 **error_code** 压栈，并把出错线性地址写入 **CR2**
3. 跳转到 Linux 页异常中断处理程序（`mm/page.s`）
4. 处理程序根据 error_code 判断：
   - 缺页异常 -->调用 **`do_no_page(error_code, CR2)`**
   - 写保护异常 -->调用 **`do_wp_page(error_code, CR2)`**

**4. 功能作用**

- **缺页异常处理**：实现 **按需分配内存** 和 **从磁盘加载数据页**
- **写保护异常处理**：实现 **写时复制**，保证进程间共享内存时的高效性与隔离性

#### 三、内核代码(进程调度)

##### 文件

~~~tree
kernel
├── asm.s
├── exit.c
├── fork.c
├── Makefile
├── mktime.c
├── panic.c
├── printk.c
├── sched.c
├── signal.c
├── sys.c
├── system_call.s
├── traps.c
├── vsprintf.c
└── who.c
~~~

##### Linux 内核代码功能分类及中断处理概述

1. **硬件中断处理类程序**

   **主要文件：**

   - `asm.s`：汇编语言实现硬件异常中断处理
   - `traps.c`：C语言实现 `asm.s` 中调用的中断处理函数

   **特点与流程：**

   - 当用户程序触发中断前，CPU 会将以下信息压入 **内核堆栈**：
     - 所有段寄存器
     - 返回地址 CS:EIP
     - EFLAGS
     - 若优先级发生变化（用户态→内核态），还会压入 SS:ESP
   - **异常中断分类**：
     - **带出错码**（int 8, int 10–14）
     - **不带出错码**（如除零错误、边界检查）
   - **处理流程（见图 5-2）**：
     1. CPU 压栈并跳转到中断处理程序
     2. asm.s 判断是否有出错码，做不同入栈处理
     3. 调用 C 函数（traps.c）处理异常
     4. 中断处理完成后，弹出堆栈信息，返回用户程序
   - **中断范围**：
     - int0–int16：Intel CPU 保留异常
     - int17–int31：保留扩展
     - int32–int47：硬件中断（时钟、键盘、硬盘等）
     - int128 (0x80)：系统调用

2. **系统调用处理程序**

   **主要文件：**

   - `system_call.s`：汇编实现系统调用入口（int 0x80）
   - `fork.c`、`signal.c`：提供 C 语言处理函数
   - `sys.c`、`exit.c`：实现具体系统调用函数 (`sys_xxx()`)

   **特点：**

   - **调用方式**：应用程序通过 int 0x80 中断调用内核功能，EAX 寄存器存放调用号
   - **函数命名规则**：
     - `do_` 开头：中断处理过程调用的通用函数或特定函数（如 `do_signal()`）
     - `sys_` 开头：指定系统调用的专用处理函数（如 `sys_execve()`）
   - `fork.c` 提供：
     - `find_empty_process()`：查找空进程表项
     - `copy_process()`：复制进程数据结构
   - `signal.c` 提供：
     - `do_signal()`：处理进程信号

3. **通用功能程序**

   **主要文件：**

   - `schedule.c`：核心调度程序
     - `schedule()`：进程调度
     - `sleep_on()` / `wakeup()`：进程阻塞与唤醒
   - `mktime.c`：内核使用的时间函数
   - `panic.c`：内核运行错误时显示信息并停机
   - `printk.c` / `vsprintf.c`：内核打印信息及字符串格式化



#### 四、文件系统

##### 文件

~~~tree
fs
├── bitmap.c
├── block_dev.c
├── buffer.c
├── char_dev.c
├── exec.c
├── fcntl.c
├── file_dev.c
├── file_table.c
├── inode.c
├── ioctl.c
├── Makefile
├── namei.c
├── open.c
├── pipe.c
├── read_write.c
├── stat.c
├── super.c
└── truncate.c
~~~

##### 总体功能概述

文件系统程序可以从功能上分为 **四大部分**：

1. **高速缓冲区管理（buffer cache）**
   - 文件：`buffer.c`
   - 作用：减少对块设备（硬盘、软盘等）的直接访问，提高系统性能
   - 主要函数：
     - `bread()`：读取块设备数据
     - `breada()`：块预读
     - `bread_page()`：按页读取多块数据
2. **文件系统低层通用函数**
   - 文件：`bitmap.c`、`inode.c`、`namei.c`、`super.c`
   - 功能：
     - **i 节点管理**：分配/释放 i 节点 (`new_inode()` / `free_inode()`)
     - **逻辑块管理**：分配/释放数据块 (`new_block()` / `free_block()`)
     - **路径解析**：通过 `namei()` 将文件路径映射到 i 节点
     - **超级块管理**：`get_super()`, `put_super()`, `free_super()`
3. **文件数据读写操作**
   - 文件：`block_dev.c`、`file_dev.c`、`char_dev.c`、`pipe.c`、`read_write.c`
   - 功能：
     - 块设备：`block_read()` / `block_write()`
     - 正规文件：`file_read()` / `file_write()`
     - 字符设备：`rw_char()`
     - 管道：`read_pipe()` / `write_pipe()`
   - 核心：系统调用 `read()` / `write()` 调用这些接口，根据文件类型选择相应处理函数
4. **文件系统系统调用接口**
   - 文件：`open.c`、`exec.c`、`fcntl.c`、`ioctl.c`、`stat.c`
   - 功能：
     - 文件操作：创建、打开、关闭、修改权限和属主
     - 可执行文件加载与执行：`do_execve()`
     - 文件句柄控制：`dup()` / `dup2()` / `fcntl()`
     - I/O 控制：`ioctl()`
     - 文件状态获取：`stat()` / `fstat()`

##### MINIX 文件系统 1.0 版结构

1. **盘上布局（360K 软盘示意）**：
   - 引导块（boot block）
   - 超级块（superblock）
   - i 节点位图（inode bitmap）
   - 逻辑块位图（zone bitmap）
   - i 节点表（inode table）
   - 数据区（data zone）
2. **超级块结构（super_block）**：
   - 文件系统元信息：i 节点数、逻辑块数、最大文件长度、修改时间
   - 位图指针：`s_imap[8]`（i 节点位图）、`s_zmap[8]`（逻辑块位图）
   - 锁定标志、只读标志、脏标志
   - 根目录 i 节点、挂载信息
3. **i 节点结构（inode）**：
   - 文件类型和权限：`i_mode`（高 4 位文件类型，低 9 位 rwx 权限）
   - 用户/组 ID：`i_uid`, `i_gid`
   - 文件长度：`i_size`
   - 修改时间：`i_mtime`
   - 链接计数：`i_nlinks`
   - 盘块号数组：`i_zone[0-6]` 直接块，`i_zone[7]` 一次间接块，`i_zone[8]` 二次间接块
4. **文件类型**：
   - 正规文件：`-`
   - 目录：`d`
   - 符号连接：`s`
   - 命名管道：`p`
   - 字符设备：`c`
   - 块设备：`b`
5. **权限表示**：
   - 三组 rwx 权限：宿主、同组用户、其他用户
   - 八进制表示常用：例如 `755`
6. 高速缓冲区（buffer cache）机制
   - 减少对慢速块设备的直接访问
   - 内核维护高速缓冲区池，将其分为缓冲块（与磁盘块大小一致）
   - 访问数据流程：
     1. 检查缓冲区是否已有数据
     2. 若有，则直接使用
     3. 若无，则从设备读取到缓冲区

#### 五、块设备驱动

##### 文件

~~~
blk_drv/
├── blk.h
├── floppy.c
├── hd.c
├── ll_rw_blk.c
├── Makefile
└── ramdisk.c
~~~

##### 块设备 I/O 处理机制

1. **数据传输单位**

   - **逻辑块（1024 字节）**：内核文件系统读写的基本单位
   - **扇区（512 字节）**：硬盘/软盘控制器的物理操作单位
      每个逻辑块 = 2 个扇区

2. **请求队列机制**

   **（1）读写流程**

   1. 用户进程请求读取逻辑块 -->交给 **缓冲区管理程序**
   2. 缓冲区检查：
      - 若已缓存 -->直接返回并唤醒进程
      - 若未缓存 -->调用 **ll_rw_block()** 发起底层请求
   3. `ll_rw_block()` 创建 **请求项 request** 并插入请求队列
      - 插入时使用 **电梯算法（电梯调度，最短寻道优先）**，以减少磁头移动距离
   4. 若该设备当前空闲 -->立即调用对应驱动请求函数（如 `do_hd_request()`）
   5. 当控制器完成传输，会产生中断 -->内核调用事先设置的中断处理函数（如 `read_intr()`、`write_intr()`）
   6. 中断处理完成后：更新缓冲区状态，唤醒等待进程，释放请求项 -->继续处理下一个请求

   **（2）块设备表 `blk_dev[]`**

   ```c
   struct blk_dev_struct {
       void (*request_fn)(void);     		// 请求处理函数
       struct request *current_request; 	// 当前正在处理的请求
   };
   extern struct blk_dev_struct blk_dev[NR_BLK_DEV];
   ```

   - 以 **主设备号**为索引
   - 示例：
     - 1 --> 虚拟盘 --> `do_rd_request()`
     - 2 -->软盘 --> `do_fd_request()`
     - 3 --> 硬盘 --> `do_hd_request()`
   - 其余设备无块设备请求函数，置为 `NULL`

   **（3）请求项结构 `request`**

   ```c
   struct request {
       int dev;              // 设备号（-1 表示空闲）
       int cmd;              // 操作命令（READ / WRITE）
       int errors;           // 错误次数
       unsigned long sector; // 起始扇区号
       unsigned long nr_sectors; // 需要读/写的扇区数
       char *buffer;         // 数据缓冲区
       struct task_struct *waiting; // 等待进程
       struct buffer_head *bh;      // 缓冲区头指针
       struct request *next;        // 链表指针
   };
   ```

   - 请求队列由数组（32 项）+ 链表组成
   - 使用数组便于循环搜索空闲项，链表便于 **电梯算法插入**
   - **读操作优先**：32 项中，前 2/3 可用于读写，后 1/3 专供读操作

   ![设备表项和请求项](.\img\设备表项和请求项.png)

3. 块设备操作流程

   **（1）写盘**

   1. 内核调用 `hd_out()` 发出写命令
   2. 等待控制器状态寄存器的 **DRQ 标志**置位（表示可以传输数据）
   3. 系统传送一个扇区数据 -->控制器写入驱动器
   4. 完成后控制器产生中断 -->调用 `write_intr()`
      - 检查是否还有剩余扇区 -->继续传输
      - 若结束 -->标记缓冲区已更新、唤醒等待进程、释放请求项 -->处理下一个请求

   **（2）读盘**

   1. 内核向控制器发出读命令（包括起始扇区、数量）
   2. 控制器将一个扇区读到自身缓冲区 -->产生中断
   3. 中断处理函数 `read_intr()`：
      - 把数据拷贝到系统缓冲区
      - 调整缓冲区写指针，递减剩余扇区数
      - 若未完成 -->继续等待下一个中断
      - 若完成 -->执行结束处理（唤醒进程、释放请求项）

   **（3）虚拟盘**

   - 完全在内存中实现，**不涉及中断处理**
   - 请求项直接在 `do_rd_request()` 内部完成

   

   

#### 六、字符设备驱动

##### 文件

~~~tree
chr_drv/
├── console.c
├── kb.S
├── Makefile
├── rs_io.s
├── serial.c
├── tty_io.c
└── tty_ioctl.c
~~~

##### 终端驱动程序原理解析

1. **终端驱动的总体功能**

   终端驱动的任务是负责 **进程与终端设备之间的数据传输**，并对数据进行一定处理：

   - **输入方向**：用户在键盘输入 -->数据经过处理（如回显、行编辑）-->最终传递给应用进程
   - **输出方向**：进程输出数据 -->终端驱动处理 -->在屏幕显示或通过串行线路发出

   终端有两种工作模式：

   1. **规范模式（canonical mode）**：输入数据被按行处理（支持删除、回车、EOF 等控制字符），提供“熟模式”数据
   2. **非规范模式（raw mode）**：输入数据原封不动地传递给进程，不做行规则处理

   行规则（line discipline）模块是模式切换和数据过滤的核心

   ![终端驱动程序流程图](.\img\终端驱动程序流程图.png)

2. **终端驱动的三大组成部分**

   Linux 0.11 中，终端驱动代码主要分为三类：

   1. **串行线路驱动**：`rs_io.s`、`serial.c`（处理 RS-232 串口）
   2. **控制台驱动**：`keyboard.S`（键盘输入）、`console.c`（屏幕输出）
   3. **上层接口与控制**：`tty_io.c`（读写）、`tty_ioctl.c`（参数配置）

3. **终端的核心数据结构**

   **(1) `tty_struct`**

   描述单个终端设备的整体信息：

   ```c
   struct tty_struct {
       struct termios termios;   // 终端 IO 属性和控制字符
       int pgrp;                 // 前台进程组 ID（作业控制）
       int stopped;              // 是否暂停标志
       void (*write)(struct tty_struct * tty); // 写函数指针
       struct tty_queue read_q;  // 读队列（raw 输入）
       struct tty_queue write_q; // 写队列（待输出）
       struct tty_queue secondary; // 辅助队列（canonical 熟模式）
   };
   ```

   - `tty_table[]`：系统中所有终端的全局表，Linux 0.11 支持 3 个终端（1 个控制台 + 2 个串行端口）

   **(2) `tty_queue`**

   字符缓冲队列（1KB 大小），保存输入/输出数据：

   - `read_q`：保存键盘或串口输入的原始字符（raw data）
   - `write_q`：保存即将输出到屏幕或串口的数据
   - `secondary`：保存经过规范模式处理后的“熟数据”，供用户程序读取

   **(3) `termios`**

   终端属性参数，定义在 `termios.h`：

   - `c_iflag`：输入模式标志（如 CR→NL 转换、大写转小写等）
   - `c_oflag`：输出模式标志（如 NL→CRNL 转换）
   - `c_cflag`：控制模式标志（如波特率、数据位、停止位）
   - `c_lflag`：本地模式标志（如回显、信号处理、ICANON）
   - `c_cc[]`：控制字符（如 INTR=Ctrl+C、EOF=Ctrl+D、ERASE=Backspace）

   ![终端数据结构](.\img\终端数据结构.png)

4. **终端工作模式**

   **(1) 规范模式（ICANON=1）**

   - 输入按行处理，支持删除/撤销/EOF 控制
   - 输入行的结束符：`NL`、`EOL`、`EOL2`、`EOF`
   - 典型功能：
     - `ERASE`：退格删除一个字符
     - `KILL`：删除整行
     - `EOF`：立即返回已输入的数据
     - 输入回车时，read() 立刻返回

   **(2) 非规范模式（ICANON=0）**

   - 输入不做行处理，直接传递给进程
   - 由 `VMIN` 和 `VTIME` 决定何时返回：
     - **MIN>0, TIME=0**：阻塞，直到收够 MIN 个字符
     - **MIN=0, TIME>0**：超时后立即返回（可能返回 0）
     - **MIN=0, TIME=0**：非阻塞，有数据即返回，否则返回 0
     - **MIN>0, TIME>0**：混合模式，超时或收够字符后返回

5. **控制台驱动流程**

   1. **键盘输入**：
      - 触发中断 -->`keyboard.S` 读取扫描码 -->转换成字符 -->放入 `read_q`
      - 调用 `do_tty_interrupt()` -->`copy_to_cooked()` -->转换后放入 `secondary`
      - 如果设置了回显标志 L_ECHO -->同时放入 `write_q` -->`con_write()` -->屏幕显示
   2. **进程输出**：
      - `write()` -->数据放入 `write_q` -->调用 `con_write()` -->显示到屏幕

6. **串行终端驱动流程**

   - **接收数据**：串口中断 (`rs_io.s`) -->将数据放入 `read_q` -->`copy_to_cooked()` -->`secondary`
   - **发送数据**：`rs_write()` 将字符放入写缓冲队列 -->硬件触发“发送保持寄存器空中断” -->中断处理函数逐个取出 `write_q` 的字符并发送

   区别：串行终端依赖 `rs_io.s`（串口中断处理），而控制台依赖 `keyboard.S` 和 `console.c`

7. **终端接口函数**

   - `tty_read()`：进程读取终端数据（来自 `secondary` 队列）
   - `tty_write()`：进程写数据到终端（进入 `write_q`，再输出）
   - `tty_ioctl()`：修改终端参数（termios 设置，如波特率、回显开关、工作模式）
   - `copy_to_cooked()`：核心过滤函数，负责 raw -->cooked 数据转换（行规则实现）

![终端字符设备和缓冲队列](.\img\终端字符设备和缓冲队列.png)

##### 总结

Linux 0.11 的终端驱动程序采用 **三层结构（串口/控制台底层驱动 + tty_io 接口层 + 行规则处理）**，利用 **缓冲队列 + termios 参数** 实现了 **规范模式与原始模式的切换**，既能支持键盘/屏幕的本地交互，也能支持远程串行终端









   

   
