### 性能分析以及调优基础

#### 一、总览

性能指标
![imag](img/系统资源出发性能指标.jpg)

性能分析总览
![imag](img/linux_perf_tools_full.png)

性能优化思维导图
![imag](img/性能分析思维导图.jpg)

#### 二、cpu篇

##### 1. 性能分析核心指标与概念
###### **1) cpu平均负载**

- 系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和CPU使用率并没有直接关系

> - 所谓可运行状态的进程，是指正在使用CPU或者正在等待CPU的进程，也就是我们常用ps命令看到的，处于R状态（Running 或 Runnable）的进程。
>
> - 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的I/O响应，也就是我们在ps命令中看到的D状态（Uninterruptible Sleep，也称为Disk Sleep）的进程
>
> 平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程

###### **2) cpu使用率**

- 单位时间内 CPU 繁忙情况的统计，就是除了空闲时间外的其他时间占总 CPU 时间的百分比

  `cpu使用率 = 1 - 空闲时间/总cpu时间`

  `平均cpu使用率 = 1 - (空闲时间1 - 空闲时间2)/(总cpu时间1 - 总cpu时间2)`

**两者区别**

> 1. CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：
>2. CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
> 3. I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；
>4. 大量等待 CPU 的进程调度也会导致平均负载升高，此时的CPU使用率也会比较高。

 **iowait 高不一定代表I/O 有性能瓶颈。当系统中只有 I/O 类型的进程在运行时，iowait 也会很高，但实际上，磁盘的读写远没有达到性能瓶颈的程度**

可以通过 `cat /proc/stat`查看cpu和任务统计信息 `man proc` 查看参数含义

- 一些参数的解释

  >- user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。
  >- nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。
  >- system（通常缩写为sys），代表内核态 CPU 时间。
  >- idle（通常缩写为id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。
  >- iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。
  >- irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。
  >- softirq（通常缩写为 si），代表处理软中断的 CPU 时间。
  >- steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。
  >- guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。
  >- guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间

###### **3) cpu上下文切换**

- CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务

 **CPU 上下文**：CPU 寄存器，程序计数器存储指令位置。它们都是 CPU 在运行任务前必须的依赖环境

**分类**

1. **进程上下文切换**

   - 进程上下文切换，是指从一个进程切换到另一个进程运行
   - 而系统调用过程中一直是同一个进程在运行

   系统调用过程通常称为特权模式切换，而不是上下文切换，但是在系统调用过程中是肯定会发生CPU上下文切换的

   ![image](img/进程上下文切换.jpg)

2. **线程上下文切换**

   - 线程是调度的基本单位，而进程则是资源拥有的基本单位

     >- 当进程只有一个线程时，可以认为进程就等于线程。
     >- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。
     >- 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

3. **中断上下文切换**
   
   - 中断处理会打断进程的正常调度和执行
   - 对同一个 CPU 来说，中断处理比进程拥有更高的优先级

###### 4) 进程状态

top 命令输出的S列（也就是 Status 列）表示进程的状态。可以看到 R、D、Z、S、I 等几个状态

```bash
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                               
    297 root      20   0       0      0      0 I   7.0   0.0   1:34.07 kworker/5:2-events
   1037 root      20   0  344948 103868  88136 S   4.7   1.3   0:25.18 Xorg                     
   7290 uos       20   0   17048   4068   3448 R   0.3   0.1   0:00.01 top               
```

- 进程状态解释

  >- **R** 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。
  >- **D** 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。
  >- **Z** 是 Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。
  >- **S** 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。
  >- **I** 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会
  >- **T 或者 t**，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态
  >- **X**，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它

###### 5) 软中断

- 中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力

为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行

中断在linux中分为两个阶段 上半部分和下半部分

>硬件中断
>
>- **上半部用来快速处理中断**，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作
>
>软中断
>
>- **下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行**
>
>上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行；
>
>而下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行
>
>每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU编号”，比如说， 0 号CPU对应的软中断内核线程的名字就是 ksoftirqd/0

一些内核自定义的事件也属于软中断，比如内核调度和RCU锁

- 查看软中断和内核线程

> /proc/softirqs 提供了软中断的运行情况；
>
> /proc/interrupts 提供了硬中断的运行情况
>
> 一，要注意软中断的类型，也就是这个界面中第一列的内容。从第一列你可以看到，软中断包括了10个类别，分别对应不同的工作类型。比如 NET_RX 表示网络接收中断，而 NET_TX 表示网络发送中断
>
> 二，要注意同一种软中断在不同 CPU 上的分布情况，也就是同一行的内容。正常情况下，同一种中断在不同 CPU 上的累积次数应该差不多。比如这个界面中，NET_RX 在 CPU0 和 CPU1 上的中断次数基本是同一个数量级，相差不大
>
> TASKLET 在不同CPU上的分布并不均匀。TASKLET 是最常用的软中断实现机制，每个 TASKLET 只运行一次就会结束 ，并且只在调用它的函数所在的 CPU 上运行

每个 CPU 都对应一个软中断内核线程，这个软中断内核线程就叫做 ksoftirqd/CPU编号

用 ps 命令就可以查询到

```
$ ps aux | grep softirq
root         7  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/0]
root        16  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/1]
```

一般来说，ps 的输出中，名字括在中括号里的，一般都是内核线程

##### 2. 一些命令的解释

###### 1) ps

```bash
ps aux | grep /app
root      4009  0.0  0.0   4376  1008 pts/0    Ss+  05:51   0:00 /app
root      4287  0.6  0.4  37280 33660 pts/0    D+   05:54   0:00 /app
root      4288  0.6  0.4  37280 33668 pts/0    D+   05:54   0:00 /app
```

> s 表示这个进程是一个会话的领导进程 
>
> \+ 表示前台进程组

- **进程组**和**会话**

  >- 进程组表示一组相互关联的进程，比如每个子进程都是父进程所在组的成员
  >- 而会话是指共享同一个控制终端的一个或多个进程组

###### 2) uptime

```
02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88
```

02:34:03               		  当前时间
up 2 days, 20:14       	系统运行时间
1 user                 			登录用户数

 后三个数字，依次则是过去1分钟、5分钟、15分钟的平均负载（Load Average）

###### 3) stress systembench

```bash
# stress 是一个 Linux 系统压力测试工具
# systembench 也是
```

###### 4) sysstat

```bash
# 包含了常用的 Linux 性能工具，用来监控和分析系统的性能 其中的命令如 mpstat 和 pidstat iostat
```

###### 5) mpstat 

```bash
mpstat -P ALL 1 # 查看cpu负载信息
mpstat -P ALL 5
05:50:31 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
05:50:36 PM  all    2.24    0.00    2.17    0.03    0.00    0.00    0.00    0.00    0.00   95.56
05:50:36 PM    0    2.05    0.00    1.84    0.00    0.00    0.00    0.00    0.00    0.00   96.11
05:50:36 PM    1    2.05    0.00    2.05    0.00    0.00    0.00    0.00    0.00    0.00   95.90
05:50:36 PM    2    2.25    0.00    2.25    0.00    0.00    0.00    0.00    0.00    0.00   95.50
05:50:36 PM    3    2.42    0.00    2.83    0.00    0.00    0.00    0.00    0.00    0.00   94.75
05:50:36 PM    4    2.65    0.00    2.24    0.00    0.00    0.00    0.00    0.00    0.00   95.10
05:50:36 PM    5    2.44    0.00    2.24    0.00    0.00    0.00    0.00    0.00    0.00   95.32
05:50:36 PM    6    2.44    0.00    2.24    0.20    0.00    0.00    0.00    0.00    0.00   95.11
05:50:36 PM    7    1.64    0.00    1.64    0.00    0.00    0.00    0.00    0.00    0.00   96.72

```

###### 6) pidstat 

```bash
pidstat -u 5 	# 查看进程占用信息
05:48:31 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:48:36 PM     0       706    0.20    0.00    0.00    0.00    0.20     0  kteamsvc
05:48:36 PM     0       708    0.20    0.00    0.00    0.00    0.20     4  kcore   

pidstat -w 4
Linux 6.12.43-amd64-desktop-rolling (erdai)     01/13/2026      _x86_64_        (8 CPU)

05:54:01 PM   UID       PID   cswch/s nvcswch/s  Command
05:54:05 PM     0         1      0.25      0.00  systemd
05:54:05 PM     0        17      5.47      0.00  ksoftirqd/0                                                 05:54:05 PM     0        18     26.87      0.00  rcu_preempt                                                 05:54:05 PM     0        22      0.25      0.00  migration/0                                                 
```

>-u 参数解释
>
>- 用户态CPU使用率 （%usr）
>- 内核态CPU使用率（%system）
>- 运行虚拟机CPU使用率（%guest）
>- 等待 CPU使用率（%wait）
>- 以及总的CPU使用率（%CPU）
>
>-w 参数解释
>
>一个是 cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数
>
>另一个则是 nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数
>
>- 所谓**自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换**。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换
>- 而**非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换**。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换

###### 7) vmstat

```bash
vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0
```

>- cs（context switch）是每秒上下文切换的次数
>
>- in（interrupt）则是每秒中断的次数
>
>- r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待CPU的进程数
>
>- 第一，应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。
>
>  第二，应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU
>
>- b（Blocked）则是处于不可中断睡眠状态的进程数

###### 8) cat /proc/interrupts

```bash
watch -d cat /proc/interrupts
# 可以查看各个cpu中断发生的次数和类型
```

###### 9) perf

```bash
perf top
Samples: 833  of event 'cpu-clock', Event count (approx.): 97742399
Overhead  Shared Object       Symbol
   7.28%  perf                [.] 0x00000000001f78a4
   4.72%  [kernel]            [k] vsnprintf
   4.32%  [kernel]            [k] module_get_kallsym
   3.65%  [kernel]            [k] _raw_spin_unlock_irqrestore
...

perf top -g
perf recrod -g
perf record -g
```

>数据格式
>
>- 第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。
>- 第二列 Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。
>- 第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。
>- 最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示

###### 10) execsnoop

```bash
execsnoop-bpfcc
PCOMM            PID    PPID   RET ARGS
pidof            6057   2683     0 /usr/bin/pidof fcitx
stress           6059   6016     0 /usr/bin/stress
pidof            6060   2683     0 /usr/bin/pidof fcitx
```

- cpu使用率很高但是检查不到高cpu应用可以使用pstree 和这个命令和perf检查 原因可能如下面两个

  >第一，应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。
  >
  >第二，应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU

###### 11) pstree

```
# -a 表示输出命令行选项
# p表PID
# s表示指定进程的父进程
$ pstree -aps 3084
systemd,1
  └─dockerd,15006 -H fd://
      └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml
          └─docker-containe,3991 -namespace moby -workdir...
              └─app,4009
                  └─(app,3084)
```

- 用于追踪子进程

  >可用于找处理僵尸进程
  >
  >要解决掉它们，就要找到它们的根儿，也就是找出父进程，然后在父进程里解决

###### 12) dstat

```
$ dstat 1 10
You did not select any stats, using -cdngy by default.
--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai stl| read  writ| recv  send|  in   out | int   csw
  0   0  96   4   0|1219k  408k|   0     0 |   0     0 |  42   885
  0   0   2  98   0|  34M    0 | 198B  790B|   0     0 |  42   138
  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  42   135
  0   0  84  16   0|5633k    0 |  66B  342B|   0     0 |  52   177
```

- 用于观察cpu和io使用情况

###### 13) strace

```
strace -p 6082
```

- 用于追用户程序的系统调用

###### 14) cat /proc/softirqs

```bash
watch -d cat /proc/softirqs
                    CPU0       CPU1
          HI:          0          0
       TIMER:    1083906    2368646
      NET_TX:         53          9
      NET_RX:    1550643    1916776
       BLOCK:          0          0
    IRQ_POLL:          0          0
     TASKLET:     333637       3930
       SCHED:     963675    2293171
     HRTIMER:          0          0
         RCU:    1542111    1590625
```

>IMER（定时中断）、NET_RX（网络接收）、SCHED（内核调度）、RCU（RCU锁）

###### 15) sar

```bash
# -n DEV 表示显示网络收发的报告，间隔1秒输出一组数据  -n DEV 参数显示网络收发的报告
sar -n DEV 1
15:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
15:03:47         eth0  12607.00   6304.00    664.86    358.11      0.00      0.00      0.00      0.01
15:03:47      docker0   6302.00  12604.00    270.79    664.66      0.00      0.00      0.00      0.00
15:03:47           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
15:03:47    veth9f6bbcd   6302.00  12604.00    356.95    664.66      0.00      0.00      0.00      0.05
```

>网络收发的吞吐量（BPS，每秒收发的字节数），网络收发的 PPS，即每秒收发的网络帧数 
>
>- 第一列：表示报告的时间。
>- 第二列：IFACE 表示网卡。
>- 第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是 PPS。
>- 第五、六列：rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是 BPS。
>- 后面的其他参数基本接近0，显然跟今天的问题没有直接关系，你可以先忽略掉

#####  3. 总结

###### 1) CPU性能指标