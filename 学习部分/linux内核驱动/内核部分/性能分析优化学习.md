### 性能分析以及调优基础

#### 一、总览

性能指标
![imag](img/系统资源出发性能指标.jpg)

性能分析总览
![imag](img/linux_perf_tools_full.png)

性能优化思维导图
![imag](img/性能分析思维导图.jpg)

#### 二、cpu篇

##### 1. 性能分析核心指标与概念
###### **1) cpu平均负载**

- 系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和CPU使用率并没有直接关系

> - 所谓可运行状态的进程，是指正在使用CPU或者正在等待CPU的进程，也就是我们常用ps命令看到的，处于R状态（Running 或 Runnable）的进程。
>
> - 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的I/O响应，也就是我们在ps命令中看到的D状态（Uninterruptible Sleep，也称为Disk Sleep）的进程
>
> 平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程

###### **2) cpu使用率**

- 单位时间内 CPU 繁忙情况的统计，就是除了空闲时间外的其他时间占总 CPU 时间的百分比

  `cpu使用率 = 1 - 空闲时间/总cpu时间`

  `平均cpu使用率 = 1 - (空闲时间1 - 空闲时间2)/(总cpu时间1 - 总cpu时间2)`

**两者区别**

> 1. CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：
>2. CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
> 3. I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；
>4. 大量等待 CPU 的进程调度也会导致平均负载升高，此时的CPU使用率也会比较高。

可以通过 `cat /proc/stat`查看cpu和任务统计信息 `man proc` 查看参数含义

- 一些参数的解释

  >- user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。
  >- nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。
  >- system（通常缩写为sys），代表内核态 CPU 时间。
  >- idle（通常缩写为id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。
  >- iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。
  >- irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。
  >- softirq（通常缩写为 si），代表处理软中断的 CPU 时间。
  >- steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。
  >- guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。
  >- guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间

###### **3) cpu上下文切换**

- CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务

 **CPU 上下文**：CPU 寄存器，程序计数器存储指令位置。它们都是 CPU 在运行任务前必须的依赖环境

**分类**

1. **进程上下文切换**

   - 进程上下文切换，是指从一个进程切换到另一个进程运行
   - 而系统调用过程中一直是同一个进程在运行

   系统调用过程通常称为特权模式切换，而不是上下文切换，但是在系统调用过程中是肯定会发生CPU上下文切换的

   ![image](img/进程上下文切换.jpg)

2. **线程上下文切换**

   - 线程是调度的基本单位，而进程则是资源拥有的基本单位

     >- 当进程只有一个线程时，可以认为进程就等于线程。
     >- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。
     >- 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

3. **中断上下文切换**
   
   - 中断处理会打断进程的正常调度和执行
   - 对同一个 CPU 来说，中断处理比进程拥有更高的优先级

###### 3) 进程状态

top 命令输出的S列（也就是 Status 列）表示进程的状态。可以看到 R、D、Z、S、I 等几个状态

```bash
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                               
    297 root      20   0       0      0      0 I   7.0   0.0   1:34.07 kworker/5:2-events
   1037 root      20   0  344948 103868  88136 S   4.7   1.3   0:25.18 Xorg                     
   7290 uos       20   0   17048   4068   3448 R   0.3   0.1   0:00.01 top               
```

- 进程状态解释

  >- **R** 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。
  >- **D** 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。
  >- **Z** 是 Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。
  >- **S** 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。
  >- **I** 是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会
  >- **T 或者 t**，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态
  >- **X**，也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它

##### 2. 一些命令的解释

###### 1) ps

```bash
ps aux | grep /app
root      4009  0.0  0.0   4376  1008 pts/0    Ss+  05:51   0:00 /app
root      4287  0.6  0.4  37280 33660 pts/0    D+   05:54   0:00 /app
root      4288  0.6  0.4  37280 33668 pts/0    D+   05:54   0:00 /app
```

> s 表示这个进程是一个会话的领导进程 
>
> \+ 表示前台进程组

- **进程组**和**会话**

  >- 进程组表示一组相互关联的进程，比如每个子进程都是父进程所在组的成员
  >- 而会话是指共享同一个控制终端的一个或多个进程组

###### 2) uptime

```
02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88
```

02:34:03               		  当前时间
up 2 days, 20:14       	系统运行时间
1 user                 			登录用户数

 后三个数字，依次则是过去1分钟、5分钟、15分钟的平均负载（Load Average）

###### 3) stress systembench

```bash
# stress 是一个 Linux 系统压力测试工具
# systembench 也是
```

###### 4) sysstat

```bash
# 包含了常用的 Linux 性能工具，用来监控和分析系统的性能 其中的命令如 mpstat 和 pidstat iostat
```

###### 5) mpstat 

```bash
mpstat -P ALL 1 # 查看cpu负载信息
mpstat -P ALL 5
05:50:31 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
05:50:36 PM  all    2.24    0.00    2.17    0.03    0.00    0.00    0.00    0.00    0.00   95.56
05:50:36 PM    0    2.05    0.00    1.84    0.00    0.00    0.00    0.00    0.00    0.00   96.11
05:50:36 PM    1    2.05    0.00    2.05    0.00    0.00    0.00    0.00    0.00    0.00   95.90
05:50:36 PM    2    2.25    0.00    2.25    0.00    0.00    0.00    0.00    0.00    0.00   95.50
05:50:36 PM    3    2.42    0.00    2.83    0.00    0.00    0.00    0.00    0.00    0.00   94.75
05:50:36 PM    4    2.65    0.00    2.24    0.00    0.00    0.00    0.00    0.00    0.00   95.10
05:50:36 PM    5    2.44    0.00    2.24    0.00    0.00    0.00    0.00    0.00    0.00   95.32
05:50:36 PM    6    2.44    0.00    2.24    0.20    0.00    0.00    0.00    0.00    0.00   95.11
05:50:36 PM    7    1.64    0.00    1.64    0.00    0.00    0.00    0.00    0.00    0.00   96.72

```

###### 6) pidstat 

```bash
pidstat -u 5 	# 查看进程占用信息
05:48:31 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:48:36 PM     0       706    0.20    0.00    0.00    0.00    0.20     0  kteamsvc
05:48:36 PM     0       708    0.20    0.00    0.00    0.00    0.20     4  kcore   

pidstat -w 4
Linux 6.12.43-amd64-desktop-rolling (erdai)     01/13/2026      _x86_64_        (8 CPU)

05:54:01 PM   UID       PID   cswch/s nvcswch/s  Command
05:54:05 PM     0         1      0.25      0.00  systemd
05:54:05 PM     0        17      5.47      0.00  ksoftirqd/0                                                 05:54:05 PM     0        18     26.87      0.00  rcu_preempt                                                 05:54:05 PM     0        22      0.25      0.00  migration/0                                                 
```

>-u 参数解释
>
>- 用户态CPU使用率 （%usr）
>- 内核态CPU使用率（%system）
>- 运行虚拟机CPU使用率（%guest）
>- 等待 CPU使用率（%wait）
>- 以及总的CPU使用率（%CPU）
>
>-w 参数解释
>
>一个是 cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数
>
>另一个则是 nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数
>
>- 所谓**自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换**。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换
>- 而**非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换**。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换

###### 7) vmstat

```bash
vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0
```

>- cs（context switch）是每秒上下文切换的次数
>
>- in（interrupt）则是每秒中断的次数
>
>- r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待CPU的进程数
>
>- 第一，应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。
>
>  第二，应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU
>
>- b（Blocked）则是处于不可中断睡眠状态的进程数

###### 8) cat /proc/interrupts

```bash
watch -d cat /proc/interrupts
# 可以查看各个cpu中断发生的次数和类型
```

###### 9) perf

```bash
perf top
Samples: 833  of event 'cpu-clock', Event count (approx.): 97742399
Overhead  Shared Object       Symbol
   7.28%  perf                [.] 0x00000000001f78a4
   4.72%  [kernel]            [k] vsnprintf
   4.32%  [kernel]            [k] module_get_kallsym
   3.65%  [kernel]            [k] _raw_spin_unlock_irqrestore
...

perf top -g
perf recrod -g
perf record -g
```

>数据格式
>
>- 第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。
>- 第二列 Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。
>- 第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。
>- 最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示

###### 10) execsnoop

```bash
execsnoop-bpfcc
PCOMM            PID    PPID   RET ARGS
pidof            6057   2683     0 /usr/bin/pidof fcitx
stress           6059   6016     0 /usr/bin/stress
pidof            6060   2683     0 /usr/bin/pidof fcitx
```

- cpu使用率很高但是检查不到高cpu应用可以使用pstree 和这个命令和perf检查 原因可能如下面两个

  >第一，应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。
  >
  >第二，应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU

###### 
